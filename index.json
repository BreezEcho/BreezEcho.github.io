[{"categories":["acweek","datastructure"],"content":"a summary about data structure","date":"2023-12-21","objectID":"/acweek2/","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":" 一些算法中常用数据结构的写法。 ","date":"2023-12-21","objectID":"/acweek2/:0:0","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"1 链表 ","date":"2023-12-21","objectID":"/acweek2/:1:0","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"1.1 单链表 原题链接 对于链表，通常用类实现较为复杂的功能，但在算法题中，为了实现我们的目的，使用静态链表就好了。 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int head, e[N], ne[N], idx; void init(){ head = -1; memset(ne, -1, sizeof ne); } void add_to_head(int x) { ne[idx] = head; head = idx; e[idx++] = x; } void deletel(int k) { if (k == 0) { head = ne[head]; } else ne[k-1] = ne[ne[k-1]]; } void insert(int k, int x) { ne[idx] = ne[k-1]; ne[k-1] = idx; e[idx++] = x; } int main() { init(); int m; cin \u003e\u003e m; while (m--) { char op; int k, x; cin \u003e\u003e op; if (op == 'H') { cin \u003e\u003e x; add_to_head(x); } else if (op == 'D') { cin \u003e\u003e k; deletel(k); } else { cin \u003e\u003e k \u003e\u003e x; insert(k, x); } } for (int j = head; j != -1; j = ne[j]) cout \u003c\u003c e[j] \u003c\u003c \" \"; return 0; } ","date":"2023-12-21","objectID":"/acweek2/:1:1","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"1.2 双链表 可以纯纯模拟，对每个操作进行细化。 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int head, e[N], ne[N], la[N], idx, tail; void init() { memset(ne, -1, sizeof ne); memset(la, -1, sizeof la); } void ladd(int x) { e[++idx] = x; ne[idx] = ne[head]; la[idx] = head; if (ne[head] != -1) la[ne[head]] = idx; ne[head] = idx; if (ne[idx] == -1) tail = idx; } void radd(int x) { e[++idx] = x; ne[tail] = idx; la[idx] = tail; tail = idx; } void deletek(int k) { if (ne[k] != -1) la[ne[k]] = la[k]; else tail = la[k]; ne[la[k]] = ne[k]; } void insertl(int k, int x) { e[++idx] = x; ne[idx] = k; la[idx] = la[k]; ne[la[k]] = idx; la[k] = idx; } void insertr(int k, int x) { e[++idx] = x; la[idx] = k; ne[idx] = ne[k]; if (ne[k] != -1) la[ne[k]] = idx; ne[k] = idx; if (ne[idx] == -1) tail = idx; } int main() { init(); int m; cin \u003e\u003e m; while (m--) { string op; int k, x; cin \u003e\u003e op; if (op == \"L\") { cin \u003e\u003e x; ladd(x); } else if (op == \"R\") { cin \u003e\u003e x; radd(x); } else if (op == \"D\") { cin \u003e\u003e k; deletek(k); } else if (op == \"IL\") { cin \u003e\u003e k \u003e\u003e x; insertl(k, x); } else { cin \u003e\u003e k \u003e\u003e x; insertr(k, x); } } for (int i = ne[head]; i != -1; i = ne[i]) cout \u003c\u003c e[i] \u003c\u003c \" \"; return 0; } 也可以增加辅助结点，简化操作设计： 使用头结点和尾结点，下标为0、1，数据元素从idx = 2开始记录。 #include \u003ciostream\u003e using namespace std; const int N = 100010; int m; int e[N], l[N], r[N], idx; // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } int main() { cin \u003e\u003e m; // 0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2; while (m -- ) { string op; cin \u003e\u003e op; int k, x; if (op == \"L\") { cin \u003e\u003e x; insert(0, x); } else if (op == \"R\") { cin \u003e\u003e x; insert(l[1], x); } else if (op == \"D\") { cin \u003e\u003e k; remove(k + 1); } else if (op == \"IL\") { cin \u003e\u003e k \u003e\u003e x; insert(l[k + 1], x); } else { cin \u003e\u003e k \u003e\u003e x; insert(k + 1, x); } } for (int i = r[0]; i != 1; i = r[i]) cout \u003c\u003c e[i] \u003c\u003c ' '; cout \u003c\u003c endl; return 0; } ","date":"2023-12-21","objectID":"/acweek2/:1:2","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"2 栈 ","date":"2023-12-21","objectID":"/acweek2/:2:0","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"2.1 模拟栈 原题链接 用数组来模拟栈的动态变化以及常见操作。 使用基本数组做容器，使用指针来维护栈的状态。 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cstring\u003e using namespace std; const int N = 1e5 + 10; int q[N]; int tt = -1; int main() { string op; int m, x; cin \u003e\u003e m; while (m--) { cin \u003e\u003e op; if (op == \"push\") { cin \u003e\u003e x; q[++tt] = x; } else if (op == \"pop\") tt--; else if (op == \"empty\") { if (tt == -1) cout \u003c\u003c \"YES\" \u003c\u003c endl; else cout \u003c\u003c \"NO\" \u003c\u003c endl; } else cout \u003c\u003c q[tt] \u003c\u003c endl; } return 0; } ","date":"2023-12-21","objectID":"/acweek2/:2:1","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"2.2 表达式求值 原题链接 表达式求值是常见的需要使用栈来协助解决的问题。如果一个表达式被使用后缀表达式描述出来，那么做顺序扫描就可以很好地计算出结果，所以本题的关键在于如何分离数和符号，然后转换为后缀表达式的计算顺序。 扫描入栈和出栈计算这两个操作可以合在一起： 扫描到数，就将其转换为整型； 扫描到符号，需要进行讨论： 若为左括号，就push 若为右括号，对于符号栈，考虑一般情况(+，做出栈计算；考虑特殊情况(就不做操作。 若为*、/，就根据符号运算优先级将因式转换为数 最后符号栈只剩加减，就不断做出栈运算，对数栈中的数进行加减代数运算即可。 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cstring\u003e #include \u003cunordered_map\u003e #include \u003cstack\u003e using namespace std; stack\u003cint\u003e num; stack\u003cchar\u003e op; unordered_map\u003cchar, int\u003e pr{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}}; void eval() { auto a = num.top(); num.pop(); auto b = num.top(); num.pop(); auto c = op.top(); op.pop(); if (c == '+') num.push(a+b); else if (c == '-') num.push(b-a); else if (c == '*') num.push(a*b); else num.push(b/a); } int main() { string str; cin \u003e\u003e str; for (int i = 0; i \u003c str.size(); i++) { auto c = str[i]; if (isdigit(c)) { int x = 0, j = i; while (j \u003c str.size() \u0026\u0026 isdigit(str[j])) { x = x*10 + str[j] - '0'; j++; } num.push(x); i = j-1; } else if (c == '(') op.push(c); else if (c == ')') { while (op.top() != '(') eval(); op.pop(); } else { while (op.size() \u0026\u0026 op.top() != '(' \u0026\u0026 pr[op.top()] \u003e= pr[c]) eval(); op.push(c); } } while (op.size()) eval(); cout \u003c\u003c num.top() \u003c\u003c endl; return 0; } 本题重在使用头文件中提供的栈类，而非自行实现。 ","date":"2023-12-21","objectID":"/acweek2/:2:2","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"3 队列 ","date":"2023-12-21","objectID":"/acweek2/:3:0","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"3.1 模拟队列 使用数组进行存储，使用指针进行维护，与模拟栈类似，懂核心原理就好。 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cstring\u003e using namespace std; const int N = 1e5 + 10; int q[N]; int hh = 0, tt = -1; int main() { int m; cin \u003e\u003e m; string op; int x; while (m--) { cin \u003e\u003e op; if (op == \"push\") { cin \u003e\u003e x; q[++tt] = x; } else if (op == \"pop\") hh++; else if (op == \"empty\") { if (hh \u003e tt) cout \u003c\u003c \"YES\" \u003c\u003c endl; else cout \u003c\u003c \"NO\" \u003c\u003c endl; } else cout \u003c\u003c q[hh] \u003c\u003c endl; } return 0; } ","date":"2023-12-21","objectID":"/acweek2/:3:1","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"4 单调栈与单调队列 ","date":"2023-12-21","objectID":"/acweek2/:4:0","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"4.1 单调栈 原题链接 单调栈的单调性主要指的是满足一定条件下的次序单调。 与普通栈的差别主要在于：在构建栈的同时也做特性相关的维护，去掉无用的信息，使得每次询问的复杂度都为O(1)。 主要需要思考的是可不可以淘汰一些旧的、影响单调性的元素。 比如初始状态下栈的内容是这样的：1、2、5。 此时扫描到4应该如何处理。 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5 + 10; int q[N], tt; int main() { int n; cin \u003e\u003e n; while (n--) { int x; cin \u003e\u003e x; while (tt \u0026\u0026 q[tt] \u003e= x) tt--; if (!tt) cout \u003c\u003c -1 \u003c\u003c \" \"; else cout \u003c\u003c q[tt] \u003c\u003c \" \"; q[++tt] = x; } return 0; } ","date":"2023-12-21","objectID":"/acweek2/:4:1","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"4.2 单调队列 滑动窗口 4.2.1 从框架入手 窗口的维护无需构建新的数据结构，只需要使用指针。 “对滑动窗口的头尾指针进行控制即可动态模拟窗口的移动。“ 贪心的基石永远是扫描遍历。 不要想着一次遍历就同时找到窗口的最大最小值序列，可以拆解问题多做几次遍历，根据输出结果也可以找到一些端倪。 “每个滑动窗口的最大和最小元素分两轮遍历确认即可。“ 4.2.2 深入细节 学会根据样例从0开始做模拟，找到可以优化的地方，这是解决任何问题的核心。 思考单调队列的单调性应该如何，本题主要取决于窗口移动过程中不断被舍弃的元素处在哪一端，可以想想如果窗口逆向移动，应该如何选择？ 思考队列里应该存什么，是数据还是下标。它取决于当窗口移动时，如何立刻找到失效的元素并剔除。 逆向思考最终需要的效果，会帮助理清细节。 4.2.3 实现 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e6+10; int a[N], q[N]; int hh, tt; int main() { int n, k; cin \u003e\u003e n \u003e\u003e k; for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; tt = -1; for (int i = 0; i \u003c n; i++) { if (hh \u003c= tt \u0026\u0026 i-k+1 \u003e q[hh]) hh++; // 考虑原最值是否被舍弃 while (hh \u003c= tt \u0026\u0026 a[q[tt]] \u003e= a[i]) tt--; // 考虑是否有无用信息可以简化 q[++tt] = i; if (i-k+1 \u003e= 0) cout \u003c\u003c a[q[hh]] \u003c\u003c \" \"; } puts(\"\"); hh = 0, tt = -1; for (int i = 0; i \u003c n; i++) { if (hh \u003c= tt \u0026\u0026 i-k+1 \u003e q[hh]) hh++; while (hh \u003c= tt \u0026\u0026 a[q[tt]] \u003c= a[i]) tt--; q[++tt] = i; if (i-k+1 \u003e= 0) cout \u003c\u003c a[q[hh]] \u003c\u003c \" \"; } return 0; } ","date":"2023-12-21","objectID":"/acweek2/:4:2","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"5 KMP字符串 字符串匹配 这个问题比较复杂，但有一位老哥的分享非常透彻，通俗易懂，可以参考一哈 关于KMP的简单理解？。 比较形象的讲解可以参考讲解。 大致的思路： 构建部分匹配表 这一步的实现需要在原模式串的基础上抽象构造一个虚块，代表一种特殊的形式。 遍历模版串，匹配模式串 找出部分匹配 or 全部匹配 实现： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e const int N = 1e5+10, M = 1e6+10; char s[M], p[N]; // s为字符串，p为模版串 int ne[N]; using namespace std; int main() { int n, m; cin \u003e\u003e n \u003e\u003e p+1 \u003e\u003e m \u003e\u003e s+1; // 让模式串自比，构建部分匹配表 for (int i = 2, j = 0; i \u003c= n; i++) { while (j \u0026\u0026 p[i] != p[j+1]) j = ne[j]; // 考虑失配的情况，兼容初始化的判别 if (p[i] == p[j+1]) j++; // 不失配，考虑更长的匹配 ne[i] = j; } // 实际匹配与上述构建匹配表时思路相似 for (int i = 1, j = 0; i \u003c= m; i++) { while (j \u0026\u0026 s[i] != p[j+1]) j = ne[j]; if (s[i] == p[j+1]) j++; if (j == n) { cout \u003c\u003c i-n \u003c\u003c \" \"; // 注意题干要求下标从0计数 j = ne[j]; } } return 0; } 值得思考的问题 在构建部分匹配表时，最笨的办法就是遍历寻找每个子串的部分匹配值，那么，如何简化寻找，注意在寻找过程中有哪些相似之处。（对应于构建部分匹配表） 代码中的i和j如何理解，尤其是它们的初始化数值，这非常重要。 ","date":"2023-12-21","objectID":"/acweek2/:5:0","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","datastructure"],"content":"6 Trie字符串统计 用树构建基本存储体系，但在实现时需要用数组来完成对树的存储。 下面是一些理解： 树的分支：不同存储元素 树的叶子：表征某数据元素的特性数据 这种存储方式的特别之处在于对目标存储元素共性的利用，从而降低存储成本。 实现： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int son[N][26], idx, cnt[N]; // 树的节点编号从0开始，但0表示根，而son数组的初始化数值0意味着节点不存在，26代表26个小写字母 char str[N]; void insert(char *str) { int p = 0; // 表示从根开始遍历，查找子节点 for (int i = 0; str[i]; i++) { int u = str[i]-'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } cnt[p]++; } int query(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i]-'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; cin \u003e\u003e n; while (n--) { char op[2]; cin \u003e\u003e op \u003e\u003e str; if (*op == 'I') insert(str); else cout \u003c\u003c query(str) \u003c\u003c endl; } return 0; } 当然也有更简单的实现： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cstring\u003e #include \u003cmap\u003e using namespace std; map\u003cstring, int\u003e d; int main() { int n; cin \u003e\u003e n; while (n--) { char op; string s; cin \u003e\u003e op \u003e\u003e s; if (op == 'I') d[s]++; else cout \u003c\u003c d[s] \u003c\u003c endl; } return 0; } 当然这里学习的是Trie这样一个数据结构，所以不推崇这种写法。 ","date":"2023-12-21","objectID":"/acweek2/:6:0","tags":["链表","栈","队列","单调结构"],"title":"Acweek2","uri":"/acweek2/"},{"categories":["acweek","base"],"content":"工作算法准备第一周，a new beginning！ ","date":"2023-10-08","objectID":"/acweek1/:0:0","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"1 排序 ","date":"2023-10-08","objectID":"/acweek1/:1:0","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"1.1 快速排序 原题链接 基本思路： 确定一个参照数据，初始化头尾指针，分别移动指针，向参照数据逼近。 先移动左指针，找到大于参照元素的位置；再移动右指针，找到小于参照元素的位置。 如果合法，即左指针位置小于右指针，就交换两个位置上的元素。 重复上述3步，分治参照数据左右两边的数列，直至找到所有元素应该在的位置。 代码： #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e using namespace std; const int N = 1e5+10; int a[N]; int n; void sort(int *q, int l, int r) { if (l \u003e= r) return; int x = q[l + r \u003e\u003e 1]; int i = l-1, j = r+1; while (i \u003c j) { do i++; while (q[i] \u003c x); do j--; while (q[j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } sort(q, l, j); sort(q, j+1, r); } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; sort(a, 0, n-1); for (int i = 0; i \u003c n; i++) cout \u003c\u003c a[i] \u003c\u003c \" \"; return 0; } 拓展： sort(q, l, j)在分治时要注意数列头尾描述的合理性。不能写成sort(q, l, i)，例如数列1 0在这样处理时会发生死循环。不能想当然地认为l与j是相等的。 数列越有序，快排性能越低；越无序，快排性能越高。 ","date":"2023-10-08","objectID":"/acweek1/:1:1","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"1.2 归并排序 原题链接 基本思路： 与快排的思路相似，两者都以分治算法为核心，只不过归并排序是先分组再处理，快排顺序相反罢了。注意每一步处理的数据对象是什么，哪些步骤可以同步处理，哪些步骤可以异步处理。 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5 + 10; int a[N], b[N]; int n; void sort(int *q, int l, int r) { if (l \u003e= r) return; int mid = (l + r \u003e\u003e 1); sort(q, l, mid); sort(q, mid+1, r); int i = l, j = mid+1, s = l; while (i \u003c= mid \u0026\u0026 j \u003c= r) { if (q[i] \u003c= q[j]) b[s] = q[i++]; else b[s] = q[j++]; s++; } for (int u = i; u \u003c= mid; u++) b[s] = q[u], s++; for (int u = j; u \u003c= r; u++) b[s] = q[u], s++; for (int u = l; u \u003c= r; u++) q[u] = b[u]; } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++ ) cin \u003e\u003e a[i]; sort(a, 0, n-1); for (int i = 0; i \u003c n; i ++ ) cout \u003c\u003c a[i] \u003c\u003c \" \"; return 0; } 拓展： 归并排序是稳定算法。 ","date":"2023-10-08","objectID":"/acweek1/:1:2","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"2 二分 原题链接 基本思路： 基于可重有序数列，不断取中部数据进行判断，缩小目标元素所在范围，常见问题是寻找重复数据的左部位置和右部位置。 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int a[N]; int n, q, k; int main() { cin \u003e\u003e n \u003e\u003e q; for (int i = 0; i \u003c n; i ++ ) cin \u003e\u003e a[i]; while (q--) { cin \u003e\u003e k; int l = 0, r = n-1; while (l \u003c r) { int mid = (l + r \u003e\u003e 1); if (a[mid] \u003e= k) r = mid; // 寻找左部数据 else l = mid + 1; } int left = l; if (a[left] != k) cout \u003c\u003c \"-1 -1\" \u003c\u003c endl; else { l = 0, r = n-1; while (l \u003c r) { int mid = (l + r + 1 \u003e\u003e 1); // 避免进入死循环，若不加1对于“1 0”就不合法，找1会进入死循环，找0则找不到。 if (a[mid] \u003e k) r = mid - 1; // 寻找右部数据 else l = mid; } int right = l; cout \u003c\u003c left \u003c\u003c \" \" \u003c\u003c right \u003c\u003c endl; } } } ","date":"2023-10-08","objectID":"/acweek1/:2:0","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"3 高精度 ","date":"2023-10-08","objectID":"/acweek1/:3:0","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"3.1 高精度加法 原题链接 基本思路： 对大长度数据使用向量逆序存储。 逆向思考，注意最终结果每一位是由哪些部分组成的，包含上一位的进位、两数对应位的和。 注意向量vector这一数据结构的特性，它是动态数组，需要避免访问越界问题。 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cstring\u003e using namespace std; vector\u003cint\u003e a, b; void add(vector\u003cint\u003e a, vector\u003cint\u003e b) { vector\u003cint\u003e c; int t = 0; for (int i = 0; i \u003c a.size(); i++) { t += a[i]; if (i \u003c b.size()) t += b[i]; c.push_back(t%10); t /= 10; } if (t) c.push_back(t); for (int i = c.size()-1; i \u003e= 0; i--) cout \u003c\u003c c[i]; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; int n1 = s1.length(), n2 = s2.length(); for (int i = n1-1; i \u003e= 0; i--) a.push_back(s1[i]-'0'); for (int i = n2-1; i \u003e= 0; i--) b.push_back(s2[i]-'0'); if (n1 \u003e= n2) add(a, b); else add(b, a); return 0; } 先关注思路和逻辑，再想想哪些地方可以优化。 ","date":"2023-10-08","objectID":"/acweek1/:3:1","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"3.2 高精度减法 原题链接 基本思路： 与高精度加采取的数据结构一致，只是操作规则不同 先判断两数的大小关系，再做相减，某种情况下加上负号 代码： #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; bool cmp(vector\u003cint\u003e \u0026A, vector\u003cint\u003e \u0026B) 比较两数大小，从位数、各位数大小分析 { if (A.size() != B.size()) return A.size() \u003e B.size(); for (int i = A.size() - 1; i \u003e= 0; i -- ) if (A[i] != B[i]) return A[i] \u003e B[i]; return true; } vector\u003cint\u003e sub(vector\u003cint\u003e \u0026A, vector\u003cint\u003e \u0026B) 两数相减 { vector\u003cint\u003e C; int t = 0; for(int i = 0; i \u003c A.size(); i++) { t = A[i] - t; if(i \u003c B.size()) t -= B[i]; C.push_back((t + 10) % 10); if(t \u003c 0) t = 1; else t = 0; } while(C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); 考虑减完后高位为0的情况 return C; } int main() { string a, b; cin \u003e\u003e a \u003e\u003e b; vector\u003cint\u003e A, B, C; for(int i = a.size() - 1; i \u003e= 0; i--) A.push_back(a[i] - '0'); for(int i = b.size() - 1; i \u003e= 0; i--) B.push_back(b[i] - '0'); if(cmp(A, B)) C = sub(A, B); else { C = sub(B, A); cout \u003c\u003c '-'; } for(int i = C.size() - 1; i \u003e= 0; i--) cout \u003c\u003c C[i]; return 0; } 拓展： 注意去掉计算过程中产生的前导零 可以对代码做进一步优化 ","date":"2023-10-08","objectID":"/acweek1/:3:2","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"3.3 高精度乘法 原题链接 基本思路： 注意乘法基本原理即可，其它方面与一般高精度运算相当。 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cstring\u003e using namespace std; vector\u003cint\u003e a; void acc(vector\u003cint\u003e a, int b) { int t = 0; vector\u003cint\u003e c; for (int i = 0; i \u003c a.size(); i ++ ) { // 注意乘法运算的基理: a*b = a[0]*b + a[1]*10*b + a[2]*100*b + ... t += a[i]*b; c.push_back(t%10); t /= 10; } if (t) c.push_back(t); while (c.back() == 0 \u0026\u0026 c.size() != 1) c.pop_back(); // 注意vector相关函数操作 for (int i = c.size()-1; i \u003e= 0; i -- ) cout \u003c\u003c c[i]; } int main() { string s; int b; cin \u003e\u003e s \u003e\u003e b; int n = s.length(); for (int i = n-1; i \u003e= 0; i --) a.push_back(s[i]-'0'); if (a[n-1] == 0 || b == 0) cout \u003c\u003c 0; else acc(a, b); return 0; } ","date":"2023-10-08","objectID":"/acweek1/:3:3","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"3.4 高精度除法 原题链接 基本思想： 与常规除法运算一致，注意结果的处理。 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cstring\u003e using namespace std; vector\u003cint\u003e a; void div(vector\u003cint\u003e a, int b) { int t = 0; vector\u003cint\u003e c; for (int i = a.size()-1; i \u003e= 0; i--) { // 注意此处与常规除法运算顺序一致，但核心仍然是以各位为核心。 t = t*10 + a[i]; c.push_back(t/b); t %= b; } reverse(c.begin(), c.end()); // 考虑到除法结果的特殊性，选择对结果做倒置 while (c.back() == 0 and c.size() != 1) c.pop_back(); for (int i = c.size()-1; i \u003e= 0; i--) cout \u003c\u003c c[i]; cout \u003c\u003c endl \u003c\u003c t; } int main() { string s; int b; cin \u003e\u003e s \u003e\u003e b; int n = s.length(); for (int i = n-1; i \u003e= 0; i --) a.push_back(s[i]-'0'); if (a[n-1] == 0) cout \u003c\u003c 0 \u003c\u003c endl \u003c\u003c 0; else div(a, b); return 0; } ","date":"2023-10-08","objectID":"/acweek1/:3:4","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"4 前缀和 ","date":"2023-10-08","objectID":"/acweek1/:4:0","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"4.1 模板 原题链接 基本思路： 简单对前n项进行累加，再使用前缀和做相关处理。 代码： #include \u003ciostream\u003e using namespace std; const int N = 100010; int a[N], s[N]; int main() { int n, m; scanf(\"%d%d\", \u0026n, \u0026m); for(int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); for(int i = 1; i \u003c= n; i++) s[i] = s[i-1] + a[i]; while(m--) { int l, r; scanf(\"%d%d\", \u0026l, \u0026r); printf(\"%d\\n\", s[r] - s[l - 1]); // - 1是离散性的体现 } return 0; } ","date":"2023-10-08","objectID":"/acweek1/:4:1","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"4.2 二维前缀和 原题链接 基本思路： 构建多维前缀和：考虑每个以原点和各坐标处数据为对角元的矩阵内数据的和 0, 0 x-1, y x, y-1 x, y 操作前缀和：思路相当，剪完再补 x1-1, y1-1 x1-1, y2 x1, y1 x2, y1-1 x2, y2 代码： #include \u003ciostream\u003e #include \u003ccstdio\u003e using namespace std; const int N = 1010; int a[N][N], s[N][N]; int main() { int n, m, q, k; int x1, y1, x2, y2; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++){ cin \u003e\u003e k; a[i][j] = k; } for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++){ s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]; } while(q--){ cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; cout \u003c\u003c s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1] \u003c\u003c endl; } return 0; } ","date":"2023-10-08","objectID":"/acweek1/:4:2","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"4.3 差分 原题链接 基本思路： 将每一个基本数据元素看作是差分序列的前缀和，将对原数据的操作复杂度从O(n)转变为O(1)。 注意题目中描述的l、r均是数组中第l、r个元素。 代码: #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int a[N], b[N]; int n, m; void insert(int l, int r, int c) { b[l] += c; b[r+1] -= c; } int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; for (int i = 0; i \u003c n; i++) insert(i, i, a[i]); while (m--) { int l, r, c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; insert(l-1, r-1, c); } for (int i = 1; i \u003c n; i ++ ) b[i] += b[i-1]; for (int i = 0; i \u003c n; i ++ ) cout \u003c\u003c b[i] \u003c\u003c \" \"; return 0; } ","date":"2023-10-08","objectID":"/acweek1/:4:3","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"4.4 二维差分 原题链接 基本思路： 基于差分，与普通差分的主要差异在于操作函数的具体步骤，需要多画图测试，使得每个数据的值能够与一定规则下的前缀和一致。 构造前缀和：参考4.2 二维前缀和 操作函数的设计：主要设置区域内的差分数值和区域外的差分数值，保证以原点和这些元素为对角元的子矩阵数据和能够表征原矩阵该位置的数值。 x1, y1 x1, y2+1 x2, y2 x2+1, y1 x2+1, y2+1 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int a[N][N], b[N][N]; int n, m, q; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x1][y2+1] -= c; b[x2+1][y1] -= c; b[x2+1][y2+1] += c; } int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for (int i = 1; i \u003c= n; i++) // 注意这里从1号位置而非0号位置开始存储，这样在做二维前缀和时才不会发生越界。 for (int j = 1; j \u003c= m; j++) cin \u003e\u003e a[i][j]; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) insert(i, j, i, j, a[i][j]); while (q--) { int x1, y1, x2, y2, c; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2 \u003e\u003e c; insert(x1, y1, x2, y2, c); } for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) b[i][j] = b[i-1][j] + b[i][j-1] - b[i-1][j-1] + b[i][j]; for (int i = 1; i \u003c= n; i++) { if (i != 1) puts(\"\"); for (int j = 1; j \u003c= m; j++) { cout \u003c\u003c b[i][j] \u003c\u003c \" \"; } } return 0; } ","date":"2023-10-08","objectID":"/acweek1/:4:4","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"5 双指针 ","date":"2023-10-08","objectID":"/acweek1/:5:0","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"5.1 最长连续不重复子序列 原题链接 基本思路： 该题为双指针的第一种应用场景，单数列双指针。 从模拟出发，遍历每个连续子序列。过程中需要用到双指针，但注意指针的移动存在依赖性，以序列尾部对子序列进行划分，可以发现每个指针的移动方向是唯一的。假设i \u003c j，如果已有[i, j]序列满足条件，那么不可能有[i-k, j+1]满足条件。基于上述性质，我们可以将整个过程的遍历复杂度由O(n^2)降至O(n)。 双指针基础模板: for (int i = 0, j = 0; i \u003c n; i++) { while (j \u003c i \u0026\u0026 check(i, j)) j++; 进行统计计算... } 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int a[N], s[N]; // s[N]统计了序列中各数值出现的次数 int n; int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++ ) cin \u003e\u003e a[i]; int j = 0, res = 0; for (int i = 0; i \u003c n; i++) { s[a[i]]++; // 加入a[i]，统计数值出现次数 while (j \u003c i \u0026\u0026 s[a[i]] \u003e 1) s[a[j++]]--; // 将a[j]移出序列，统计数值出现次数 res = max(res, i - j + 1); } cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2023-10-08","objectID":"/acweek1/:5:1","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"5.2 数组元素的目标和 原题链接 基本思路： 找准双指针的移动方向，利用指针之间的相互影响对某个指针的移动范围进行缩小，筛掉不必要的步骤，也就找到了优化的方向。 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5 + 10; int a[N], b[N]; int n, m, x; int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e x; for (int i = 0; i \u003c n; i ++ ) cin \u003e\u003e a[i]; for (int i = 0; i \u003c m; i ++ ) cin \u003e\u003e b[i]; for (int i = 0, j = m-1; i \u003c n; i++) { while (j \u003e= 1 \u0026\u0026 a[i] + b[j] \u003e x) j--; if (j \u003e= 0 \u0026\u0026 a[i] + b[j] == x) { cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c j; } } return 0; } ","date":"2023-10-08","objectID":"/acweek1/:5:2","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"5.3 判断子序列 原题链接 基本思路： 与5.2 数组元素的目标和解法相当，只不过初始化时两个指针都需要放在数组的头部。 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int a[N], b[N]; int n, m; int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c n; i ++ ) cin \u003e\u003e a[i]; for (int i = 0; i \u003c m; i ++ ) cin \u003e\u003e b[i]; int ant = 0; for (int i = 0, j = 0; i \u003c n; i++) { while (j \u003c m \u0026\u0026 a[i] != b[j]) j++; if (j \u003c m \u0026\u0026 a[i] == b[j]) { ant++; j++; continue; } } if (ant == n) cout \u003c\u003c \"Yes\"; else cout \u003c\u003c \"No\"; return 0; } ","date":"2023-10-08","objectID":"/acweek1/:5:3","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"6 位运算、离散化、区间合并 ","date":"2023-10-08","objectID":"/acweek1/:6:0","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"6.1 二进制数中1的个数 原题链接 基本思路： 熟悉二进制与十进制之间相互转化的算法，利用该原理将二进制形式下的每一位拆出来就行。 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int a[N], b[N]; int n; int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++ ) cin \u003e\u003e a[i]; for (int i = 0; i \u003c n; i ++ ) { int ant = 0, t = a[i]; while (t != 0) { if (t%2) ant++; t /= 2; } b[i] = ant; } for (int i = 0; i \u003c n; i ++ ) cout \u003c\u003c b[i] \u003c\u003c \" \"; return 0; } ","date":"2023-10-08","objectID":"/acweek1/:6:1","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"6.2 区间和（离散化） 原题链接 基本思路： 对于大范围数据，采用离散化思路，将它们放在一定长度的有序数列。 暂存各种修改与请求操作，并记录这些操作的元素下标。 对存储的元素下标进行排序和去重，保证数据的前后顺序一致。 再次遍历修改操作，直接作用于离散化数组，然后在此基础上预处理离散化前缀和。 再次遍历查询操作，利用前缀和序列计算结果。 简单来说就是经历了数据离散化、预处理前缀和、利用前缀和求解这三个过程。 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 300010; int a[N], s[N]; vector\u003cPII\u003e add, query; vector\u003cint\u003e alls; int n, m; int find(int x) { int l = 0, r = alls.size()-1; while (l \u003c r) { int mid = (l + r \u003e\u003e 1); if (alls[mid] \u003e= x) r = mid; else l = mid+1; } return r+1; } int main() { cin \u003e\u003e n \u003e\u003e m; while (n--) { int x, c; cin \u003e\u003e x \u003e\u003e c; add.push_back({x, c}); alls.push_back(x); } while (m--) { int l, r; cin \u003e\u003e l \u003e\u003e r; query.push_back({l, r}); alls.push_back(l); alls.push_back(r); } sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); for (auto item: add) { int u = item.first, v = item.second; int x = find(u); a[x] += v; } for (int i = 1; i \u003c= alls.size(); i++) s[i] = s[i-1] + a[i]; for (auto item: query) { int u = find(item.first), v = find(item.second); cout \u003c\u003c s[v] - s[u-1] \u003c\u003c endl; } return 0; } ","date":"2023-10-08","objectID":"/acweek1/:6:2","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":["acweek","base"],"content":"6.3 区间合并 原题链接 基本思路： 存储区间，并按左端点进行排序，这样对于两个区间只需要考虑3种而非4种情况。 贪心，分析区间的左右端点即可，遍历每个区间，分情况讨论即可。 代码： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; typedef pair\u003cint, int\u003e PII; vector\u003cPII\u003e segs; int n; void merge(vector\u003cPII\u003e \u0026segs) { vector\u003cPII\u003e res; int st = -2e9, ed = 2e9; for (auto seg: segs) { if (st == -2e9 || seg.first \u003e ed) { res.push_back(seg); st = seg.first; ed = seg.second; } else ed = max(ed, seg.second); } segs = res; } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i ++ ) { int l, r; cin \u003e\u003e l \u003e\u003e r; segs.push_back({l, r}); } sort(segs.begin(), segs.end()); merge(segs); cout \u003c\u003c segs.size(); return 0; } ","date":"2023-10-08","objectID":"/acweek1/:6:3","tags":["排序","二分","高精度","前缀和","双指针","位运算"],"title":"Acweek1","uri":"/acweek1/"},{"categories":[],"content":"当网站中出现0101的空文件时，可以检查一下是否有YAML为空的文章，通常情况这是对未标识属性文档的判别。 ","date":"2023-09-16","objectID":"/buglog/:0:0","tags":[],"title":"错误报告01","uri":"/buglog/"},{"categories":["algorithm"],"content":"树状数组和线段树 树状数组相比线段树更快，代码更短 ","date":"2023-03-15","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/:0:0","tags":["树状数组","线段树","数据结构"],"title":"树状数组和线段树","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["algorithm"],"content":"一.树状数组 树状数组的下标是从1开始的 基本功能 在某个位置上加上一个数，即单点修改 求某个前缀和，即区间查询 树状数组的每个元素c[x]表示A[x]中区间[x-lowbit(x), x]里的数的和，lowbit(x)表示x的二进制形式后0的个数，也可以表示为x\u0026-x // 求和 for(int i = x; i; i -= lowbit(i), res += c[i]) return res; // 递归形式求和 // 对某数进行修改后需要进行的调整 A[x] += v; // 对x位置数进行加法改变 for(int i = x; i \u003c N; i += lowbit(i), c[x] += v) // 每次指标上升一层 解决问题需要的操作决定了数据结构的选取，比如如果要修改某个元素且需要修改某个子序列的和，那么就可以用树状数组。数据结构的难点也在这里 ","date":"2023-03-15","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/:1:0","tags":["树状数组","线段树","数据结构"],"title":"树状数组和线段树","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["algorithm"],"content":"例：动态求连续区间和 给定 n 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 [a,b] 的连续和。 输入格式 第一行包含两个整数 n 和 m，分别表示数的个数和操作次数。 第二行包含 n 个整数，表示完整数列。 接下来 m 行，每行包含三个整数 k,a,b （k=0，表示求子数列[a,b]的和；k=1，表示第 a 个数加 b）。 数列从 1 开始计数。 输出格式 输出若干行数字，表示 k=0 时，对应的子数列 [a,b] 的连续和。 数据范围 1≤n≤100000, 1≤m≤100000， 1≤a≤b≤n, 数据保证在任何时候，数列中所有元素之和均在 int 范围内。 输入样例： 10 5 1 2 3 4 5 6 7 8 9 10 1 1 5 0 1 3 0 4 8 1 7 5 0 4 8 输出样例： 11 30 35 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003ccstdio\u003e using namespace std; const int N = 100010; int n, m; int tr[N], w[N]; int lowbit(int x) { return x\u0026-x; } void add(int x, int v) { for(int i = x; i \u003c= n; i += lowbit(i)) tr[i] += v; } int query(int x) { int res = 0; for(int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for(int i = 1; i \u003c= n; i++) cin \u003e\u003e w[i]; for(int i = 1; i \u003c= n; i++) add(i, w[i]); while(m--) { int k, a, b; scanf(\"%d%d%d\", \u0026k, \u0026a, \u0026b); if(k == 0) cout \u003c\u003c query(b) - query(a-1) \u003c\u003c endl; else add(a, b); } return 0; } ","date":"2023-03-15","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/:1:1","tags":["树状数组","线段树","数据结构"],"title":"树状数组和线段树","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["algorithm"],"content":"二.线段树 存储: 一维数组，与堆的存储方式相同。 通常有两个操作： 单点修改 区间查询 基本函数： pushup 用子节点信息更新当前节点信息 build 在一段区间上初始化线段树 modify 修改 query 某区间的特定关系 ","date":"2023-03-15","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/:2:0","tags":["树状数组","线段树","数据结构"],"title":"树状数组和线段树","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["algorithm"],"content":"例：数列区间最大值 输入一串数字，给你 M 个询问，每次询问就给你两个数字 X,Y，要求你说出 X 到 Y 这段区间内的最大数。 输入格式 第一行两个整数 N,M 表示数字的个数和要询问的次数； 接下来一行为 N 个数； 接下来 M 行，每行都有两个整数 X,Y。 输出格式 输出共 M 行，每行输出一个数。 数据范围 1≤N≤105, 1≤M≤106, 1≤X≤Y≤N, 数列中的数字均不超过231−1 输入样例： 10 2 3 2 4 5 6 8 1 2 9 7 1 4 3 8 输出样例： 5 8 题解： 本题中modify操作没有体现，之后会用线段树实现一遍动态求连续区间和，开个坑。 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003ccstdio\u003e #include \u003cclimits\u003e using namespace std; int m, n; const int N = 100010; int w[N]; struct Node { int l, r; int maxv; }tr[4*N]; void build(int u, int l, int r) { if(l == r) tr[u] = {l, r, w[r]}; else { tr[u] = {l, r}; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid), build(u \u003c\u003c 1 | 1, mid+1, r); tr[u].maxv = max(tr[u \u003c\u003c 1].maxv, tr[u \u003c\u003c 1 | 1].maxv); } } int query(int u, int l, int r) { if(tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].maxv; int mid = tr[u].l + tr[u].r \u003e\u003e 1; int maxm = INT_MIN; if(l \u003c= mid) maxm = max(maxm, query(u \u003c\u003c 1, l, r)); if(r \u003e mid) maxm = max(maxm, query(u \u003c\u003c 1 | 1, l, r)); return maxm; } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for(int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026w[i]); build(1, 1, n); int x, y; while(m -- ) { scanf(\"%d%d\", \u0026x, \u0026y); printf(\"%d\\n\", query(1, x, y)); } return 0; } ","date":"2023-03-15","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/:2:1","tags":["树状数组","线段树","数据结构"],"title":"树状数组和线段树","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["ACDaily"],"content":"数学与简单DP ","date":"2023-03-03","objectID":"/acdaily-3/:0:0","tags":["算法中的数学"],"title":"ACDaily 3","uri":"/acdaily-3/"},{"categories":["ACDaily"],"content":"数学（根据例题讲解） ","date":"2023-03-03","objectID":"/acdaily-3/:1:0","tags":["算法中的数学"],"title":"ACDaily 3","uri":"/acdaily-3/"},{"categories":["ACDaily"],"content":"买不到的数 小明开了一家糖果店。 他别出心裁：把水果糖包成4颗一包和7颗一包的两种。 糖果不能拆包卖。 小朋友来买糖的时候，他就用这两种包装来组合。 当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。 你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。 大于17的任何数字都可以用4和7组合出来。 本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。 输入格式 两个正整数 n,m，表示每种包装中糖的颗数。 输出格式 一个正整数，表示最大不能买到的糖数。 数据范围 2≤n,m≤1000， 保证数据一定有解。 输入样例： 4 7 输出样例： 17 题解 #include \u003ciostream\u003e using namespace std; int main() { int n, m, res = 0; cin \u003e\u003e n \u003e\u003e m; res = (m-1)*(n-1) - 1; cout \u003c\u003c res; return 0; } 找最大公约数，如哦不是最大公约数的倍数则无解 打表找规律，裴蜀定理，获得公式，具体公式推导可以参考AcWing525 最后进行公式输出即可 递归能够确定终点，需要由终点进行反推，来判断深搜是否成立，中间进行的递归是为了确定深搜中不同的方向（与二叉树相似） 注意这仅仅是打表 最终还要根据数据表内的信息来寻找规律 ","date":"2023-03-03","objectID":"/acdaily-3/:1:1","tags":["算法中的数学"],"title":"ACDaily 3","uri":"/acdaily-3/"},{"categories":["ACDaily"],"content":"感冒的蚂蚁 长 100 厘米的细长直杆子上有 n 只蚂蚁。 它们的头有的朝左，有的朝右。 每只蚂蚁都只能沿着杆子向前爬，速度是 1 厘米/秒。 当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。 这些蚂蚁中，有 1 只蚂蚁感冒了。 并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。 请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。 输入格式 第一行输入一个整数 n, 表示蚂蚁的总数。 接着的一行是 n 个用空格分开的整数 Xi, Xi 的绝对值表示蚂蚁离开杆子左边端点的距离。 正值表示头朝右，负值表示头朝左，数据中不会出现 0 值，也不会出现两只蚂蚁占用同一位置。 其中，第一个数据代表的蚂蚁感冒了。 输出格式 输出1个整数，表示最后感冒蚂蚁的数目。 数据范围 1\u003cn\u003c50, 0\u003c|Xi|\u003c100 输入样例1： 3 5 -2 8 输出样例1： 3 题解 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ccstring\u003e using namespace std; const int N = 60; int a[N]; int main() { int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; int right = 0, left = 0; for(int i = 0; i \u003c n; i++) { if(abs(a[i]) \u003c abs(a[0]) \u0026\u0026 a[i] \u003e 0) left++; if(abs(a[i]) \u003e abs(a[0]) \u0026\u0026 a[i] \u003c 0) right++; } if(a[0] \u003e 0 \u0026\u0026 right == 0 || a[0] \u003c 0 \u0026\u0026 left == 0) cout \u003c\u003c 1 \u003c\u003c endl; else cout \u003c\u003c left+right+1 \u003c\u003c endl; return 0; } 做简单的魂穿假设，蚂蚁之间碰撞之时，方向不改变，但个体的性质发生变化 分析 首先以感染源蚂蚁为核心，按是否可能被感染将左右两边的蚂蚁进行分类 判断感染源蚂蚁的行进方向，进行最终被感染蚂蚁的计算 ","date":"2023-03-03","objectID":"/acdaily-3/:1:2","tags":["算法中的数学"],"title":"ACDaily 3","uri":"/acdaily-3/"},{"categories":["ACDaily"],"content":"饮料换购 乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊C型饮料，凭3个瓶盖可以再换一瓶C型饮料，并且可以一直循环下去(但不允许暂借或赊账)。 请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的 n 瓶饮料，最后他一共能喝到多少瓶饮料。 输入格式 输入一个整数 n,表示初始买入的饮料数量。 输出格式 输出一个整数，表示一共能够喝到的饮料数量。 数据范围 0\u003cn\u003c10000 输入样例： 100 输出样例： 149 题解 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e using namespace std; int main() { int n; cin \u003e\u003e n; int res = n; while(n \u003e= 3) { res += n/3; n = (n/3) + (n%3); } cout \u003c\u003c res; return 0; } 注意这是一个上下取整问题 注意每次都要尽可能将瓶盖换掉，不到多余 ","date":"2023-03-03","objectID":"/acdaily-3/:1:3","tags":["算法中的数学"],"title":"ACDaily 3","uri":"/acdaily-3/"},{"categories":["日志"],"content":"1. encrypt加密 找到themes\\LoveIt\\layouts\\posts\\single.html文件,在{{- $params := .Scratch.Get \"params\" -}}的下一行添加下列内容： {{- $password := $params.password | default \"\" -}} {{- if ne $password \"\" -}} \u003cscript\u003e (function(){ if({{ $password }}){ if (prompt('请输入文章密码') != {{ $password }}){ alert('密码错误！'); if (history.length === 1) { window.opener = null; window.open('', '_self'); window.close(); } else { history.back(); } } } })(); \u003c/script\u003e {{- end -}} 之后只要在文章的头部加上password属性即可进行加密，只有输入了正确密码才能打开文章，否则会回退到之前的页面。用法如下： --- title: 随笔 password: test --- ","date":"2023-02-06","objectID":"/20230206/:1:0","tags":["日志","博客维护"],"title":"博客维护日志-230206","uri":"/20230206/"},{"categories":["日志"],"content":"2. 博客主题更新 在博客根目录下进行如下操作： git clone https://github.com/khusika/FeelIt.git themes/FeelIt 在themes文件目录下会生成一个名为FeelIt的主题文件。 为了同步更新主题文件，可以将FeelIt设置为网站目录的子模块。 git submodule add https://github.com/khusika/FeelIt.git themes/FeelIt 之后在themes/FeelIt/content/examplesite目录下找到主题的配置文件，为了更好地维护，建议将其作为网站根目录的配置文件，即将本主题设置为默认主题。不要在主题文件中进行配置，以防配置更新导致数据丢失。 最后，可以将主题目录下的assets和layout文件夹直接复制到网站根目录下，保证展示效果。 若要进行展示，可以执行: hugo serve --disableFastRender 不过由于修改了配置文件，而public文件并没有进行更新，所以，建议先删除原来的public文件，然后重新执行hugo命令来进行生成。 经过了以上操作，博客更新就大体完成了。 ","date":"2023-02-06","objectID":"/20230206/:2:0","tags":["日志","博客维护"],"title":"博客维护日志-230206","uri":"/20230206/"},{"categories":["日志"],"content":"3. config.toml文件说明 初始的配置文件结构不太清晰，需要进行二次描述，做结构切分。 个人感觉语言切换这个功能目前不太常用，所以可以选择一个主语言，将其设置为默认状态，然后将其它语言的配置部分删除，注意保证留下语言和默认语言的一致性。 ","date":"2023-02-06","objectID":"/20230206/:3:0","tags":["日志","博客维护"],"title":"博客维护日志-230206","uri":"/20230206/"},{"categories":["日志"],"content":"4. 网页角标设置 本主题使用的符号集为fontawesome，可以通过html引用相关图标，具体格式为： \u003ci class='fas fa-img fa-fw'\u003e\u003c/i\u003e 其中fa-img可以替换为你想要的图标名称，具体可在官网进行查询。不过需要注意的是，博客使用的本地字体集版本可能较低，图标引用语法与最新方式有所不同，所以需要以本地引用格式为准。 ","date":"2023-02-06","objectID":"/20230206/:4:0","tags":["日志","博客维护"],"title":"博客维护日志-230206","uri":"/20230206/"},{"categories":["日志"],"content":"5. 备忘录 文章banner设置的图片标准为1600*840 win11下的任务管理器快捷键为ctrl+shift+esc ","date":"2023-02-06","objectID":"/20230206/:5:0","tags":["日志","博客维护"],"title":"博客维护日志-230206","uri":"/20230206/"},{"categories":["悟道"],"content":"平庸与卓越之间的差别，不在于天赋，而在于长期的坚持、持续的投入。 本文编辑整理自清华大学陈吉宁校长履新环保部前，于2015年1月27日清华大学第一次研究生毕业典礼暨学位授予仪式上的演讲。 亲爱的同学们： 今天，共有1318名同学获得博士、硕士学位。首先，我代表学校，向同学们奋力拼搏完成学业表示祝贺！同时，向悉心指导你们的老师、辛勤培育你们的家人和一路支持你们的亲友，致以诚挚的敬意和衷心的感谢！ 最近我一直在思考，在今天这个场合，给大家讲点什么。大家知道，在过去几次毕业典礼上，我曾经讲过理想、担当、良知、敬畏等一些关于价值信念的话题，勉励同学们在实现自我价值和履行家庭责任的同时，肩负起推动国家富强、民族复兴、人类文明进步的时代重任。这既是对同学们提出的一些做人做事方面的希望，也是我自己经历中的一些感悟和体会。今天，我想和大家交流的话题是：选择与坚持。前不久，我在台湾访问的时候见到一本书，书名叫《Outliers》，书的内容与去年全校教育工作讨论会的主题很吻合，我就买了下来，在回北京的路上很快读完了。书中讲了很多故事来说明社会环境、机遇对一个人成功的重要作用。不过，我从这些故事中得到了一些新的不同的感受和启示，在此与大家分享。 第一是从现在做起，从小事做起，不要怨天尤人。 这本书讲到加拿大冰球国家队的故事，作者发现在这些国家队选手中有一个规律性现象——他们大部分人都出生在1、2月份，很少有在年底出生的。之所以出现这种现象，是因为在加拿大这个冰球运动狂热的国家，教练们会挑选9到10岁的小选手组成“巡回赛小组”，而分组的时间界线恰好是1月1日，换句话说，1月1日到当年12月31日之间出生的球员会被分在一组。对10来岁的孩子来说，几个月的年龄差距还是很明显的，那些大月份出生的小孩发育更成熟，更容易在同组竞争中胜出。而一个小选手一旦被选中，他将拥有更好的教练、更出色的队友、参加更多的比赛。久而久之，这些孩子的成绩会越来越好，其中最优秀的一部分人就进入到国家队。大月份出生的运动员从一开始幸运地获得了那些微小的机会，并通过努力逐渐把这些机会累积成自己的优势，最终成为国家队选手。这个规律不仅存在于加拿大冰球运动中，在美国的棒球运动、欧洲的足球运动甚至在学校教育中也有类似现象。 这告诉我们，每件事情的起步阶段都很重要，不要因为事情小就忽视它，不要因为是刚开始就不认真去做。同学们，你们离开学校后，身边的每一件小事都可能是积累未来发展优势的那个机会。希望大家迈好这走向社会的第一步，从小事做起，从现在做起，从身边的一点一滴做起，把自己的成长融入到国家发展、社会进步的洪流中，即使遇到了困难和挫折，也决不要消极悲观、怨天尤人。这是我想说的第一点体会。 第二是要长期坚持，全心投入，不要轻易放弃。 大家在学校时有不少观看高水平演出的机会。当我们陶醉于婉转悠扬的乐曲时，经常会赞叹演奏者的高超技巧，并可能会将此归功于他们的非凡天赋。《Outliers》这本书却讲了另外一个发现：无论是小提琴还是钢琴专业的学生，他们从5岁左右开始学琴，到20岁时，那些具有成为世界级独奏家潜质的学生都至少练习了10000小时，那些被认为比较优秀的学生累计练习了8000小时，而那些被认为将来只能成为一名音乐辅导老师的学生只练习了4000小时。这就是所谓的“10000小时法则”，如果一个人的技能要达到世界水准，他（她）的练习时间通常需要超过10000小时。这个法则也应验在我们熟知的很多著名人士身上。比如，比尔.盖茨就几乎把自己的青少年时光都用在了计算机程序开发上。从1968年他上七年级开始，到大二退学创办微软公司，这期间盖茨持续编程有7年时间，远远超过10000小时，据说当时世界上有盖茨这样经历的人不超过50个。因此，当1975年个人计算机开始进入家庭时代的黎明时刻，能占据最有利的位置去拥抱第一缕曙光的人，自然非“盖茨”们莫属。前不久，Facebook创始人扎克伯格来清华演讲，我问了他一个问题——对于创业者来说，什么最重要？他不假思索地回答，“不要放弃”。我们的古人也说，行百里者半九十。做一件事情，只有持之以恒地坚持下去，你才能从中产生对事物的深刻理解和认识，获得与众不同的感悟和洞察，这是一个人成长不可或缺的重要过程。没有这样的积累，即便机会到了你的面前，也很难能把握住。所以，平庸与卓越之间的差别，不在于天赋，而在于长期的坚持、持续的投入。这是我想告诉大家的第二点体会。 我要说的第三点是，要懂得取舍，有所不为，不要被眼前利益所诱惑。 去年下半年，苹果公司首席执行官蒂姆.库克在清华有一个对话活动。当被问到“在过去3年中哪些是你做的最困难的决策”时，库克回答说，最难的是“决定不做什么”。因为苹果公司有太多伟大的、令人兴奋的想法。他又被问到，是不是要从好的想法中选择最好的想法，去掉次好的想法？令人惊讶的是，库克说，我们所有的想法都是最好的想法，但苹果公司只能选择其中一种，并努力把它做到极致，其他的都会果断放弃。同学们，人的成长就是一个不断选择的过程，对优秀的人而言，选择更是人生中面临的最大挑战。今天你们走向社会，将面临各种各样的机遇、诱惑，也会遇到很多的挑战、挫折。每当这时候，你都是在回答与“选择”相关的问题。我希望大家，无论面对机会还是挑战，都能有舍弃的胸怀和勇气，都能从国家利益出发、从大众福祉出发，选择最有价值的事情，专心专注地做下去，在服务国家、奉献社会的事业中让自己从优秀走向更加优秀。 同学们，刚才我讲的是自己从很多人、很多事中得到的三点感悟。当然，即使大家做到了这三点，也未必一定能获得你所期望的结果。但我相信，只要做到了从小事做起，从现在做起，持之以恒，勇于舍弃，你们会从自己的每一次经历中收获对成功与失败更为深刻的理解。那时候，世界依然属于你，创造精彩人生的空间依然为你敞开。正如敬爱的朱镕基学长在纪念经管学院建院30周年时，对清华同学们讲的那样，“要大胆地试，不要怕失败；你们还年轻，失败了也无所谓”。 来源：《新华日报》2015年2月4日 ","date":"2023-02-05","objectID":"/%E5%B9%B3%E5%87%A1%E4%B8%8E%E5%BA%B8%E4%BF%97%E7%9A%84%E5%B7%AE%E8%B7%9D%E4%B8%8D%E5%9C%A8%E5%A4%A9%E8%B5%8B/:0:0","tags":["可持续发展","坚持","试错"],"title":"平庸与卓越之间的差别不在于天赋","uri":"/%E5%B9%B3%E5%87%A1%E4%B8%8E%E5%BA%B8%E4%BF%97%E7%9A%84%E5%B7%AE%E8%B7%9D%E4%B8%8D%E5%9C%A8%E5%A4%A9%E8%B5%8B/"},{"categories":["悟道"],"content":"人生终归会经历起起落落，但真正的高手，无论外部环境优劣，无论自身运气好坏，总是能持之以恒的遵循计划 ：稳扎稳打，步步为营，日积跬步，以致千里。具体的成功路径或许无法复刻，但真正的高手身上总有一些共性，这正是我们复盘历史、学习他人的意义。今天的文章通过重新解读几个经典的故事，拆解高手成功的战略秘籍，希望能带给你思考与能量。 ","date":"2023-02-04","objectID":"/continue/:0:0","tags":["可持续性","发展"],"title":"真正的高手，在于稳定性与可持续性","uri":"/continue/"},{"categories":["悟道"],"content":"01 日拱一卒，功不唐捐 这是一个发生在一百年前的故事。 截止到1911年12月，没有哪个地球人到达过南极点，所以这是一百年前所有最伟大的探险者、所有最有探险精神及梦想的人最想做到的事情。 最后是两个竞争团队打算完成这项创举，一个是来自挪威的阿蒙森团队，另一个是英国的斯科特团队，他们都想率先完成这个从来没有人完成过的事情，到达南极点。 他们出发时间是差不多的，这是因为这个世界上的竞争从来都是非常激烈的，当有一个大的机会出现时，没有可能只有你一个人看到了，而是差不多时候有一帮人看到了。这跟其他无数场合的竞争都很像。 所以这两支团队差不多都是1911年10月在南极圈的外围做好了准备，准备进行最后的冲刺。 结果是这样的，阿蒙森团队在两个多月后，也就是1911年12月15日，率先到达了南极点，插上了挪威国旗。 而斯科特团队虽然出发时间差不多，可是他们晚到了很多，他们晚到了一个多月，这意味着什么？ 这就是成功跟失败的区别： 阿蒙森团队作为人类历史上第一个到达南极点的团队会永载史册，获得一切的荣誉； 而斯科特团队他们虽然经历了一样的艰难险阻，但是晚了一个多月。 没有人会记住第二名，大家只知道第一名。 探险家阿蒙森在南极点的挪威国旗之下 这个故事并没有这么简单，你不光要到南极点，你还要活着回去。 阿蒙森团队率先到达南极点之后，他们又顺利地返回了原来的基地； 而斯科特团队晚到了，他们没有获得荣誉。而且更糟糕的是，他们因为晚了，回去的路上天气非常差，路上不断地有人掉队，最后他们没有任何一个人生还。 斯科特团队不但没有完成首先到达南极点的目标，而且全军覆没，这已经是生与死的区别了。 那么是什么造成这么重大的区别，不光是成功与失败的区别，而且是生与死的区别？对这个事情进行研究，可能对我们做事会有些帮助和启发。 首先，去南极探险，不光是需要人，还需要物资，事后有人总结分析两个队的策略和两个队的准备，可以看到非常重要的区别。 阿蒙森团队物资准备非常非常充分，他们是三吨的物资。而斯科特团队准备的东西少，他们只有一吨的物资。 一吨的物资够吗？如果你在过程中不犯任何错，完全不犯任何错的话，刚好够。 这是多么可怕的事情，理论上可行，但现实中碰到很大的压力、碰到很大的未知困难，你不可避免地会动作走形，会犯很多错。所以，当你的计划定得太紧的时候，其实是非常非常危险的。 而阿蒙森团队做得非常好，他们准备了三吨的物资，这些物资有极大的富余量。他们充分预知到环境的困难，做好充足的准备，给自己留下了犯错的空间。 事实上，他们碰到的环境是差不多的，最后两个团队却有截然不同的结果，这个是非常值得研究的。 阿蒙森团队的成功经验，最后可以总结成一句话：不管天气好坏，坚持每天前进大概30公里。 在一个极限环境里面，你要做到最好，但更重要的是，你要做到可持续的最好。 相反，斯科特团队从他们的日志来看，是一个比较随心所欲的团队，天气很好就走得非常猛，可能四五十公里甚至六十公里。 但天气不好的时候，他们就睡在帐篷里，吃点东西，诅咒恶劣的天气，诅咒运气不好，希望尽快天转晴，尽快能够前进。 事后总结，这两种做法很可能是他们最大的区别。不管环境好坏，不管容易与否，坚持每天前进三十公里；不管是到达南极点还是从南极点顺利返回。这是一个非常重要的区别。 阿蒙森团队于1912年1月25日全部返回营地。这个日子和他3年前计划的归程一天不差，是巧合也是奇迹。 后来有人评价阿蒙森的成功是因为好运，他的回答是： “最重要的因素是探险的准备如何，你必须要预见可能出现的困难，遇到了该如何处理或者如何避免。 成功等待那些井井有条的人——人们管这个叫做好运气。对于那些不能预见困难并做出及时应对的人来说，失败是难以避免的——人们称这个为坏运气。” 这个故事还有一些细节也值得我们思考： 斯科特团队用的是矮种马来拉雪橇，而阿蒙森团队用的是爱斯基摩犬。阿蒙森团队足足准备了97条爱斯基摩犬，阿蒙森认为只有爱斯基摩犬才是南极冰天雪地中的最佳选择。相比而言，马更强壮，开始的时候走得更快，但马不够耐寒，走到半路都冻死了，最后只能靠人力来拉雪橇；爱斯基摩犬虽然走得慢，但能在很冷的条件下生存，从而保证了行进速度。 阿蒙森为了极地探险，曾经和爱斯基摩人生活了一年多时间，就为了跟他们学习如何在冰天雪地里生活、求生等。 阿蒙森的计划非常周详，连午餐也作了特别的安排。 他使用了一种新设计的保温瓶，在每天启程前早餐时，便把热饭菜装在保温瓶里。这样午餐可以在任何时间吃，既节约燃料，又省时间。 而由于需要扎营生火，斯科特团队吃顿午餐要多花1个小时。 阿蒙森的队员时常坐在雪橇上，一边欣赏极地的奇异风光，一边嚼着暖瓶里的热饭，而且还有休假：星期天哪怕再适于行路，阿蒙森也不改变习惯。 ","date":"2023-02-04","objectID":"/continue/:1:0","tags":["可持续性","发展"],"title":"真正的高手，在于稳定性与可持续性","uri":"/continue/"},{"categories":["悟道"],"content":"02 通盘无妙手 “通盘无妙手”是一个下棋的术语，原话叫做“善弈者通盘无妙手”——也就是说很会下棋的人，往往一整盘棋你是看不到那种神奇的一招，或者力挽狂澜的一手的。 这有点违反我们的直觉，为什么是这样呢？ 1.下棋的“通盘无妙手” 韩国有一位围棋选手叫李昌镐，是围棋界的世界级顶尖高手，下围棋的人都知道他。 李昌镐16岁就夺得了世界冠军，被认为是当代仅次于吴清源的棋手，巅峰时期横扫中日韩三国棋手，号称 “石佛”，是围棋界一等一的高手。 李昌镐下棋最大的特点，也是最让对手头疼的手法，就是从不追求“妙手”，而是每手棋，只求51%的胜率，俗称“半目胜”。 通常，一局棋下来，总共也就200-300手，即使每手棋只有一半多一点的胜率，最多只要一百多手，就能稳操胜券。也就是说，只要每一步比对手好一点点，就足够赢了。 李昌镐曾对记者说： “我从不追求妙手，也没想过要一举击溃对手。” 世界排名第一的棋手，居然只追求51%的胜率，让很多记者和业内人士都觉得不可思议。 这恰恰是高手的战略，所谓的“妙手”，虽然看起来很酷，赢得很漂亮，但存在一个问题——给对方致命一击的同时，往往也会暴露自己的缺陷。正所谓“大胜之后，必有大败；大明之后，必有大暗”。 而且，“妙手”存在不稳定和不可持续性，无法通过刻意练习来形成技能上的积累，一旦“灵感”枯竭，难免手足无措。正如守卫一座城池，只靠“奇兵”是不行的，终归要有深沟、高垒的防护。 而与之相比，“通盘无妙手”看似平淡无奇，但是积胜势于点滴、化危机于无形，最终取得胜利是稳稳当当的，体现的是不同于“妙手”的另一种智慧。 真正的高手是不太会去做这些看起来风光无限的事情，因为他们懂得“善弈者通盘无妙手”。那些看起来很风光的事情，其实风险很大，失误率高，一次失误后果就很严重。 巴菲特的合作伙伴芒格说，如果我知道自己会死在哪儿，那我一辈子不去那里就好了。 这类人他们站在全局的高度来看问题，提前防范危险，消除隐患，把威胁化解于无形。 2. 台球的“通盘无妙手” 如果你打过或看过斯诺克台球比赛应该知道，它是这样的一项运动： 台子上有各种不同颜色的球，代表不同的分数，两个人按照规则轮流击球。而且只要球进了，就可以一直打，直到自己打丢了一颗球，就换对方上场击球，最后看谁得的分数多。 所以，斯诺克台球比赛非常重要的就是保持自己击球的连续性。 在打球的时候，球手一定要对整盘球的形势有整体的分析和规划，并且每一杆击球都要为下一杆做好铺垫，这样才能打得比较顺，否则就是自己给自己制造麻烦。 于是纵观斯诺克的历史，有两类球手是非常顶尖，经常拿下大赛冠军的： 1）球手天赋极佳，击球特别准，即使对别人来说难度很高的球他也能打进。虽然整体控制局势的能力稍差，可能在局面上给自己“挖坑”，但由于自己总能超水平发挥，打得别人没办法，所以也能夺得冠军。 2）球手对局面的掌控非常完美，每一杆每一次计算都非常到位，给后面留了很多的余地和铺垫。看这种人打球你会发现他很少有那种难度很大，非常精彩的击球，但他经常不知不觉、波澜不惊地就赢下了比赛。这样的球手也能获得大赛的冠军。 不过，这两类顶尖选手有一个最大的区别——后一类球手职业生涯的长度往往比前一类要长得多。 而前一种天赋型的选手，往往会在巅峰期的几年里非常耀眼，但下滑也会很快，过了一阵就会淡出公众的视野了。 3. 守门员的“通盘无妙手” 大家都知道，在足球场上，守门员是个非常重要的位置。 但外行看守门员的水平，往往会在意那些特别精彩的扑救，比如飞身一跃把一脚势大力沉的射门扑出去，这确实非常精彩；但是懂业务的人评价一个守门员，其实是看他是否能把问题化于无形。 比如历史上一些伟大的足球守门员，其实都是后防线的指挥家。他会观察对手的进攻路线和模式，然后帮助整条后卫线做好整体规划，把很多问题消解在无形中。 所以，你在场上不会看到他们经常有超水平发挥的精彩扑救，主要是因为他们早就杜绝了隐患，把对方有威胁的射门化解在了无形中。 这才是一个足球守门员的高境界。 4. 医者的“通盘无妙手” 中国有句古话：“善战者无赫赫之功，善医者无煌煌之名。”这两句意思是说：善于打仗的人往往没有什么显赫的功绩，而好的医生没有很大的名声。 扁鹊是春秋战国时的名医，他有两个哥哥，三兄弟都精通医术。 魏文王曾问扁鹊： “你们家兄弟三人都精于医术，谁的医术是最好的呢？” 扁鹊回答： “大哥最好，二哥差些，我是三人中最差的一个。” 魏王不解地说： “但是你的名气却是最大的啊。” 扁鹊解释说： “大哥治病，是在病情发作之前，那时候病人自己还不觉得有病，但大哥就下药铲除了病根，使他的医术难以被人认可，所以没有名气，只是在我们家中被推崇备至。 我的二哥治病，是在病初起之时，症状尚不十分明显，病人也没有觉得痛苦，二哥就能药到病除，使乡里人都认为二哥只是治小病很灵。 我治病，都是在病情十分严重之时，病人痛苦万分，病人家属心急如焚。 此时，他们看到我在经脉上穿刺，用针放血，或在患处敷以毒药以毒攻毒，或动大手术直指病灶，使重病人病情得到缓解或很快治愈，所以我名闻天下。” 魏王大悟。 ","date":"2023-02-04","objectID":"/continue/:2:0","tags":["可持续性","发展"],"title":"真正的高手，在于稳定性与可持续性","uri":"/continue/"},{"categories":["悟道"],"content":"03 结硬寨，打呆仗 清朝末年，太平天国起义，太平军战斗力极强，大清国20万八旗兵和60万绿营兵在其面前都不堪一击，可最终却毁在了曾国藩率领的湘军手里，这是怎么回事呢？ 曾国藩一生可以分为三个阶段： 第一阶段是文人生涯，从6岁读书到27岁中进士，一直做到大学士，是当时的学术领袖； 第二阶段是军人生涯，太平天国运动中，自己组建湘军，缠斗13年，愣是把悬崖边上的大清王朝拉了回来续了命； 第三阶段是引入西方科学文化。他组织建造了中国第一艘轮船，建立了第一所兵工学堂，引入第一批西方书籍，送出去第一批留美学生。 前后两阶段都是文人的事，但一介书生怎么战胜当时战斗力爆裂的太平军呢，这是个有趣的战略研究。 不了解情况的一定以为曾国藩是一个熟读兵法、足智多谋的战略家，其实恰恰相反。 在他带领湘军之前，并没有多少带兵打仗的经验，也不懂什么用兵之道。之所以能赢，其实就六个字——结硬寨，打呆仗。 曾国藩从来不与敌军硬碰硬地短兵相接，即使在胜算很大的情况下也从不主动发动攻击，而是每到一个地方就在城外扎营，然后挖战壕、筑高墙，把进攻变成防守，先让自己处于不败之地。 太平军是非常骁勇善战的，总想跟湘军野战，而湘军就是守着阵地不动，就算太平军再能打，碰到这种路数，也是毫无办法。只要一有时间，湘军就开始不停地挖沟，一道又一道，直到让这个城市水泄不通、断草断粮，等到城里弹尽粮绝之后，再轻松克之。 就这样，一座城接着一座城，一点一点地挖沟，一步步地往前拱，就把太平天国给拱没了。湘军每打一个城市，都不是用一天两天，而是用一年两年，大部分的时间都在挖壕沟。 当时的湘军看起来更像是一个施工队，被湘军攻打过的城市，如安庆、九江等，城外的地貌都被当年所挖的壕沟改变了。 湘军与太平军纠斗13年，除了攻武昌等少数几次有超过3000人的伤亡，其他时候，几乎都是以极小的伤亡，获得战争胜利。 这就靠曾国藩六字战法：结硬寨，打呆仗。 《孙子兵法》中说：“先为不可胜，以待敌之可胜。” 所谓 “结硬寨，打呆仗”，简而言之，就是先占据不败之地，然后慢慢获得细小优势。 曾国藩是一个爱用“笨”方法的人，他不喜欢取巧的东西，也不相信什么四两拨千斤的事情。因为胜利果实从来不是强攻出来的，而是它熟透了，自己掉下来的。《孙子兵法》里说：“胜可知，而不可为。” 美团王兴在接受采访时对记者说： “多数人对战争的理解是错的，战争不是由拼搏和牺牲组成的，而是由忍耐和煎熬组成的。” 无论是战争、商业还是个人层面，道理都一样，要想走出困境或者取得胜利，靠的都是耐心，而不是某个突发性的、奇迹般的胜利。 很多时候，你只需要按部就班地做好自己该做的事，等时机来临时，一切都会有所改变，只是在那之前，你必须要有足够的耐心。 ","date":"2023-02-04","objectID":"/continue/:3:0","tags":["可持续性","发展"],"title":"真正的高手，在于稳定性与可持续性","uri":"/continue/"},{"categories":["悟道"],"content":"04 结 语 最后，我希望能和你一起，记住这些精彩的故事，汲取前人留给我们的经验教训： 无论外界环境优劣、不管运气好坏，都不怨天尤人。按照自己的计划，稳扎稳打，步步为营，每天进步一点，到来年这个时候再回头来看，你就会发现，你已经走出了很远的距离。 林肯有句话说得好：我走得慢，但我绝不退后。 来源：“红与绿” ","date":"2023-02-04","objectID":"/continue/:4:0","tags":["可持续性","发展"],"title":"真正的高手，在于稳定性与可持续性","uri":"/continue/"},{"categories":["随笔"],"content":" 对于我来说，生活的盼头，就是在获得立身之本的智慧的同时，去追寻自己所热爱的东西，不断发掘这个世界的多元性并与之建立联系。 比如我喜欢新西兰民谣、风光摄影和cg作品，在课业之余我就会给自己一段时间去享受，长短不重要，重要的是那种纯粹的、无目的性的感觉。 某些机缘巧合下我发现花花的歌、人像摄影、还有国风水墨画也挺不错，那么我就会觉得：欸，这些领域我也可以挖掘一下。 我认为这个就是追寻热爱、发掘多元性的过程，它带给我纯粹的快乐。 我们可以有这样的想法，但常常会迷失，包括我自己。 而迷失的诱因主要有两点：成长环境、心理环境。 这两点如果讲深了感觉可以写篇专业论文哈哈，不过经历过的应该懂的都懂，我就直接给出我的处理方式。 而对一个人成长环境影响最大的就是家庭，人生不像是打游戏，不会从”请选择你的英雄“开始。我们不能保证我们的家庭质量，但是我们可以选择自己的活法，将人生的控制权掌控在自己的手里。最差的情况，如果感觉周围没有人能理解你，例如父母的不支持抑或是伤害、朋友的不理解。那就不妨孤身一人，过滤掉外界的噪声。当然这里不是建议大家一直寡着，而是需要有一种把自己交给自己的能力，如果有一对能无时无刻支持自己的父母，或是能找到一两个知己，那都是再好不过的。 然后是心理环境，迷失主要源于不断的自我怀疑。很多时候我们自以为可以被称为烦恼的东西其实都不是烦恼，在时间的长河里甚至连浪花都算不上。不妨想一想，你有多少次烦恼源于自我否定。例如，我认为自己没有好听的声音，所以不能上台唱歌；或是我认为自己没有足够的实力，所以无法参加比赛等等。能不能自由的表演只有在你尝试了才知道，所以，如果真心想做，大胆去做、不断练习就可以了，没有那么多犹豫与烦恼，只有决心的有无。 安身立命、强大内心、追逐热爱，永远闪闪发光。 祝愿看到这篇随笔的各位都能找寻到自己想要的生活。 希望对最近情绪状态不好的uu们能有所帮助。 ","date":"2022-10-30","objectID":"/%E7%94%9F%E6%B4%BB%E6%80%9D%E8%80%83/:0:0","tags":["迷失","盼头"],"title":"关于生活的一点点思考","uri":"/%E7%94%9F%E6%B4%BB%E6%80%9D%E8%80%83/"},{"categories":["documentation"],"content":"1. 本地配置 ","date":"2022-09-13","objectID":"/blogstory/:1:0","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"1.1 git相关资源下载 下载git 安装相关包管理器，例如npm和yum，包管理器中含有某些博客主题需要的依赖 设置git账号：global、local ","date":"2022-09-13","objectID":"/blogstory/:1:1","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"1.2 hugo下载 上官方网站进行下载，详情请见hugo release，注意下载hugo-extended版，适配性更强。 下载完毕后，将文件路径/bin加入环境变量，重启电脑，打开命令行输入命令hugo version，若产生hugo版本号则证明安装完成。 ","date":"2022-09-13","objectID":"/blogstory/:1:2","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"1.3 博客的配置 主流的个人博客搭建引擎包括hexo和hugo，这两个文件的主要差别在于主题配置的读取上，hexo博客根目录下的config.yaml文件比theme主题内置的config.yaml文件优先级更低，如果在根目录配置下指明了主题文件信息，那么引擎就会优先渲染后者；hugo与此相反，更侧重于主题文件的更新维护，所以一般需要将主题文件的配置拷贝到根目录下。具体的差异可以参考hexo与hugo的异同。 我的博客用的是hugo-lovelt主题，主题配置参考lovelt官方文档即可，根目录主题配置记得参照主题文档examplesite下的.conf文件。 在博客的主题的选择上，我踩了很多坑，一些主题文档的维护相当不好。在选择一款喜欢的主题时，一定要关注官方文档的质量哦。 ","date":"2022-09-13","objectID":"/blogstory/:1:3","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"2. 云服务器配置 ","date":"2022-09-13","objectID":"/blogstory/:2:0","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"2.1 云主机购买与配置 云主机的选择：阿里云、腾讯云、华为云，这三款是主流。 关于云主机的购买，具体可参考acwing-linux相关课程： 云服务器的购买 云主机的配置： 我购买的是腾讯云的轻量级服务器，系统为linux下的ubuntu。在系统分配好云主机后，我们的初始化登录是一个叫ubuntu的账户。与一般的云服务器不同，腾讯云初始化没有root用户，但ubuntu拥有sudo权限。注意sudo权限与root权限有一定差异。具体的差异详见sudo与root。 然后我们可以进行的一些操作： 2.1.1 创建acs用户 建立： # ubuntu根目录~下 adduser acs # 创建用户acs usermod -aG sudo acs # 给用户acs分配sudo权限 注意当我们cd acs或ubuntu时会进入到它们的根目录，但这个电脑下的系统设置文件在/下，也就是说，我们需要cd /才能看到到这台主机下的所有配置文件。同时，我们之后下载的很多文件都会被保存在/etc中。 2.1.2 安装tmux和docker tmux安装教程 sudo apt-get update # linux从服务器获取软件更新情况 sudo apt-get install tmux 在安装完成后，可以通过scp将一些tmux配置文件上传至云端，启用tmux，然后在命令行进行些许配置即可完成对tmux的美化。 tmux # ctrl + b : 进入tmux命令行模式 source-file ~/.tmux.conf # 让tmux配置生效 docker安装教程 在用户（有sudo权限，比如ubuntu）根目录下，按照docker-ubuntu 安装说明中的\"Install using the repository\"进行安装即可，注意一条条cv执行命令。 ","date":"2022-09-13","objectID":"/blogstory/:2:1","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"2.2 域名的购买与ssl证书申请 购买方面，挑选自己喜欢的域名进行购买即可。 在购买完域名后，需要经过实名验证、域名审核等流程。 之后可以申请ssl安全证书，一切按照腾讯云指引操作即可。 在申请完成后，可以对证书进行下载，会得到五个文件，我们只需要将其中的密钥对文件进行移动就行，后缀分别为.crt和.key，目标位置为/etc/nginx 为了网站长期的运行，我们需要对域名进行备案，这是国内的法律要求。 ","date":"2022-09-13","objectID":"/blogstory/:2:2","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"2.3 nginx的下载与配置 2.3.1 nginx下载与基础配置 下载方面，可以参照ubuntu安装nginx，内容非常详细，特别注意不同文件的安装位置，由于root用户初始化一般不存在，所以在安装时应该在sudo权限用户下使用sudo apt-get install nginx进行安装。 在安装完成后，我们进行一些基础设置： # 设置开机启动nginx sudo systemctl enable nginx # 启动nginx sudo systemctl start nginx # 查看是否启动nginx sudo systemctl status nginx # 逐行执行 在浏览器搜索框输入服务器公网ip地址，如果会出现nginx的页面，说明可以导航到服务器，即nginx安装成功。为了使外部用户可以访问web服务器，需要开放防火墙，主要是80端口和443端口，可以在服务器的控制台手动设置，同时也可以命令行设置： sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=https sudo firewall-cmd --reload 2.3.2 nginx高级配置 仿照hugo-txcloud-nginx中的nginx.conf进行配置即可。 ","date":"2022-09-13","objectID":"/blogstory/:2:3","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"3. 建立本地与云端的联系 ","date":"2022-09-13","objectID":"/blogstory/:3:0","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"3.1 初步连接 使用ssh工具进行远程访问 ssh username@server_ip 交互窗口会提醒你输入密码 ","date":"2022-09-13","objectID":"/blogstory/:3:1","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"3.2 配置免密登录 在完成过远程访问后，就可以配置免密登录。 在本地进入 ~/.ssh ssh-keygen -t rsa 生成密钥，按照指引为密钥添加文件名 密钥生成教程可访问 https://blog.csdn.net/qq_40932679/article/details/117487540 然后按照下述命令将公钥添加到远程服务器，最终会被添加在.ssh中的authorized_key文件内 ssh-agent bash # 启动ssh高速缓存 ssh-add -i ~/.ssh/txcloud.pub username@server_ip # 将公钥添加到目标用户端下 关于ssh-agent可以参考 https://blog.csdn.net/weixin_43972437/article/details/114578337 接着，在.ssh/查看有无config文件，若没有就新建一个 打开config文件，按照如下格式进行配置 # 腾讯云 Host server1 HostName 43.143.88.173 User acs IdentityFile ~/.ssh/txcloud Host server0 HostName 43.143.88.173 User ubuntu IdentityFile ~/.ssh/txcloud 这样我们的免密登录就配置好了，注意到，对不同用户要进行分别配置，但它们所使用的公密钥可以相同。 ","date":"2022-09-13","objectID":"/blogstory/:3:2","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"3.3 使用winscp与云端进行图形化文件交互 winscp下载 如果连接用户并非root用户，参考winscp修复远程连接进行修改 ","date":"2022-09-13","objectID":"/blogstory/:3:3","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"4. 建立本地与github的联系 ","date":"2022-09-13","objectID":"/blogstory/:4:0","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"4.1 git账号管理 使用邮箱注册github账号，并登录 在本地使用命令ssh-keygen -t rsa -C \"username@server_ip\"生成注释 为“username@server_ip”的密钥对，在生成的过程中可以为密钥对命名。然后将公钥.pub文件的内容进行复制，在github用户setting下的SSH and GPG keys模块新建ssh key，key name任意取，将公钥内容添加到下方加密区，完成添加。 回到本地， 如果git存在多账号，那么需要按如下方式进行管理，打开config文件: # github user Host X Hostname github.com User BreezEcho PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_x # github user Host Y Hostname github.com User huansong-dev PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_y 关于git多账号配置详情请见 https://www.cnblogs.com/wanan-happy/p/14588504.html 然后将私钥加入ssh-agent进行管理：ssh-add id_rsa_x 、ssh-add id_rsa_y 在配置完成后，可以使用ssh -T git@X来检验是否完成了连接 为了使用便利，我们可以将常用的账号设置为全局账号 git config --global user.name username git config --global user.email useremail 如果在某个仓库需要使用特殊账号，可以进行如下操作 cd base # 进入该仓库 git config --local user.name username git config --local user.email useremail ","date":"2022-09-13","objectID":"/blogstory/:4:1","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"4.2 建立本地仓库与远程仓库的联系 远程新建名为为user_id.src的私人仓库，用于管理博客项目 本地新建仓库hblog，如果是hugo site，执行hugo new site hblog 在设置好仓库账号后，进入hblog，并按照如下操作进行关联 git init # 初始化为git本地仓库 git remote -v # 查看关联情况 git remote add origin git@X:username/username.github.io.git # 建立联系 ","date":"2022-09-13","objectID":"/blogstory/:4:2","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"4.3 博客项目文件推送 # 进入博客根目录 touch .nojekyll # 默认不使用github pages自带的jekyll主题，空文件 git add . # 为所有文件添加追踪，之后的一切变化都可以通过git status进行查看 git commit -m \"ud\" # 将追踪文件的变化上传到本地仓库 git push -u origin master # 首次推送信息，之后可以将-u省去 之后如果远程仓库有变化，需要先git pull origin master，可能会出现git merge提醒，这个时候允许合并，然后再执行上述步骤。 ","date":"2022-09-13","objectID":"/blogstory/:4:3","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"5. 使用github actions将博客展示文件部署到github pages与云端服务器 主要参考： hugo双端部署，给我最大灵感的文章。 hugo+github action 少数派 ","date":"2022-09-13","objectID":"/blogstory/:5:0","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"5.1 github actions + public -\u003e github pages 5.1.1 赋予项目仓库访问本账号下其它仓库的特权 新建名为user_id.github.io的公共仓库，注意user_id为你的用户名，这样的名称格式相对固定。这个仓库用来展示我们的博客内容。 进入github用户界面的setting下: 选择右上角新建个人密钥，选中repo和workflow，然后点击生成。注意密钥只会出现一次，记得复制。将这里得到的密钥添加到我们项目仓库的actions secrets，并命名为PERSONAL_TOKEN 5.1.2 建立github actions工作流 首先，我们将项目仓库的默认分支改为master(setting中)，然后进入项目actions模块，新建工作流文件gh-pages.yml，配置参考如下，可按需求进行修改： name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \"0 0 * * *\" jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: pseudoyu/pseudoyu.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 然后等待一段时间，就可以看到工作流正常，进入博客展示仓库，可以发现多了一个master分支。 一段时间后，访问站点user_id.github.io就可以看到博客内容啦。 ","date":"2022-09-13","objectID":"/blogstory/:5:1","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"5.2 github actions + public -\u003e txcloud 5.2.1 给予项目仓库访问云服务器的特权 与本地密钥访问云服务器类似，我们需要先得到一个密钥对，然后分别将公钥和密钥置入服务端与用户端。 在本地ssh-keygen -t rsa 创建密钥对，参考上述步骤将公钥放入云端用户的authorized_key中，将私钥放入项目仓库的actions secrets内。 这个操作告诉我们密钥在哪里产生不重要，重要的是公钥与私钥的位置，就像锁与匙。 5.2.2 维护文件权限 在云主机相应用户目录下新建public空文件夹，通过ls -al命令我们发现文件的所有人以及组内用户都是合理的。如果之前public文件位置与此不符，就需要对nginx配置文件进行调整。 5.2.3 更新项目仓库actions文件 在gh-pages.yml文件中添加以下模块，并根据实际情况做一些修改，注意yaml文件的格式。 - name: Deploy Tencent Cloud uses: wlixcc/SFTP-Deploy-Action@v1.2.4 with: username: 'root' #ssh user name server: '${{ secrets.SERVER_IP }}' #引用之前创建好的secret ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }} #引用之前创建好的secret local_path: './public' # 对应我们项目public的文件夹路径，注意不能访问内部文件，因为此处没有令牌 remote_path: '/home/username/' # 对应云上的目录 等待片刻，观察工作流正常，进入云主机对应文件夹，发现文件已更新，同时权限正确。至此，github actions云部署完成。 ","date":"2022-09-13","objectID":"/blogstory/:5:2","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["documentation"],"content":"6. 结语 这次经历让我意识到，弯路，也是成长的一部分；同时，在项目中的学习效率是非常高的，当然还需要不断更新信息搜集算法。这篇文章会在后面慢慢丰富，形成一篇合格的教程。 ","date":"2022-09-13","objectID":"/blogstory/:6:0","tags":["博客搭建日志","心得"],"title":"BlogStory","uri":"/blogstory/"},{"categories":["ACDaily"],"content":"枚举、模拟问题续 ","date":"2022-03-10","objectID":"/acdaily-8/:0:0","tags":["模拟","规格化输入与输出"],"title":"ACDaily 8","uri":"/acdaily-8/"},{"categories":["ACDaily"],"content":"1.移动距离 X星球居民小区的楼房全是一样的，并且按矩阵样式排列。 其楼房的编号为 1,2,3… 当排满一行时，从下一行相邻的楼往反方向排号。 比如：当小区排号宽度为 6 时，开始情形如下： 1 2 3 4 5 6 12 11 10 9 8 7 13 14 15 ….. 我们的问题是：已知了两个楼号 m 和 n，需要求出它们之间的最短移动距离（不能斜线方向移动）。 输入格式 输入共一行，包含三个整数 w,m,n，w 为排号宽度，m,n 为待计算的楼号。 输出格式 输出一个整数，表示 m,n 两楼间最短移动距离。 数据范围 1≤w,m,n≤10000, 输入样例： 6 8 2 输出样例： 4 题解： 考虑枚举每个数，按照排列方式将单个数字转化为对应的二维坐标，进行计算即可。 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e using namespace std; int main() { int w, m, n; cin \u003e\u003e w \u003e\u003e m \u003e\u003e n; int mx, my, nx, ny; for(int i = 0; i \u003c 10000; i++) { int min = w*i+1, max = w*(i+1); if(m \u003e= min \u0026\u0026 m \u003c= max \u0026\u0026 i%2 == 0) mx = m-min, my = i; if(m \u003e= min \u0026\u0026 m \u003c= max \u0026\u0026 i%2 != 0) mx = max-m, my = i; if(n \u003e= min \u0026\u0026 n \u003c= max \u0026\u0026 i%2 == 0) nx = n-min, ny = i; if(n \u003e= min \u0026\u0026 n \u003c= max \u0026\u0026 i%2 != 0) nx = max-n, ny = i; } cout \u003c\u003c abs(mx-nx)+abs(my-ny) \u003c\u003c endl; return 0; } ","date":"2022-03-10","objectID":"/acdaily-8/:1:0","tags":["模拟","规格化输入与输出"],"title":"ACDaily 8","uri":"/acdaily-8/"},{"categories":["ACDaily"],"content":"2.日期问题 小明正在整理一批历史文献。这些历史文献中出现了很多日期。 小明知道这些日期都在1960年1月1日至2059年12月31日。 令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。 更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。 比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。 给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？ 输入格式 一个日期，格式是”AA/BB/CC”。 即每个’/’隔开的部分由两个 0-9 之间的数字（不一定相同）组成。 输出格式 输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。 多个日期按从早到晚排列。 数据范围 0≤A,B,C≤9 输入样例： 02/03/04 输出样例： 2002-03-04 2004-02-03 2004-03-02 题解： 架构： 选择规格化输入，可以避免很多麻烦 已知日期范围，枚举日期种数，简化代码逻辑 按题意对日期进行自由组合 判别日期的合理性 规格化输出，注意补前导零 #include \u003ccstdio\u003e #include \u003ciostream\u003e using namespace std; int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; bool check_valid(int year, int month, int day) { if (month == 0 || month \u003e 12) return false; if (day == 0) return false; if (month != 2) { if (day \u003e days[month]) return false; } else { int leap = ((year % 4 == 0 \u0026\u0026 year % 100 != 0) || (year % 400 == 0)); if (day \u003e days[month] + leap) return false; } return true; } int main() { int a, b, c; scanf(\"%d/%d/%d\", \u0026a, \u0026b, \u0026c); for (int date = 19600101; date \u003c= 20591231; date ++ ) { int year = date / 10000, month = date % 10000 / 100, day = date % 100; if (check_valid(year, month, day)) { if ((year % 100 == a \u0026\u0026 month == b \u0026\u0026 day == c) || // 年/月/日 (month == a \u0026\u0026 day == b \u0026\u0026 year % 100 == c) || // 月/日/年 (day == a \u0026\u0026 month == b \u0026\u0026 year % 100 == c) ) //月/日/年 printf(\"%d-%02d-%02d\\n\", year, month, day); //补前导0 } } return 0; } ","date":"2022-03-10","objectID":"/acdaily-8/:2:0","tags":["模拟","规格化输入与输出"],"title":"ACDaily 8","uri":"/acdaily-8/"},{"categories":["ACDaily"],"content":"3.航班时间 小 h 前往美国参加了蓝桥杯国际赛。 小 h 的女朋友发现小 h 上午十点出发，上午十二点到达美国，于是感叹到“现在飞机飞得真快，两小时就能到美国了”。 小 h 对超音速飞行感到十分恐惧。 仔细观察后发现飞机的起降时间都是当地时间。 由于北京和美国东部有 12 小时时差，故飞机总共需要 14 小时的飞行时间。 不久后小 h 的女朋友去中东交换。 小 h 并不知道中东与北京的时差。 但是小 h 得到了女朋友来回航班的起降时间。 小 h 想知道女朋友的航班飞行时间是多少。 对于一个可能跨时区的航班，给定来回程的起降时间。 假设飞机来回飞行时间相同，求飞机的飞行时间。 输入格式 一个输入包含多组数据。 输入第一行为一个正整数 T，表示输入数据组数。 每组数据包含两行，第一行为去程的起降时间，第二行为回程的起降时间。 起降时间的格式如下: h1:m1:s1 h2:m2:s2 h1:m1:s1 h3:m3:s3 (+1) h1:m1:s1 h4:m4:s4 (+2) 第一种格式表示该航班在当地时间h1时m1分s1秒起飞，在当地时间当日h2时m2分s2秒降落。 第二种格式表示该航班在当地时间h1时m1分s1秒起飞，在当地时间次日h2时m2分s2秒降落。 第三种格式表示该航班在当地时间h1时m1分s1秒起飞，在当地时间第三日h2时m2分s2秒降落。 输出格式 对于每一组数据输出一行一个时间hh:mm:ss，表示飞行时间为hh小时mm分ss秒。 注意，当时间为一位数时，要补齐前导零，如三小时四分五秒应写为03:04:05。 数据范围 保证输入时间合法（0≤h≤23,0≤m,s≤59），飞行时间不超过24小时。 输入样例： 3 17:48:19 21:57:24 11:05:18 15:14:23 17:21:07 00:31:46 (+1) 23:02:41 16:13:20 (+1) 10:19:19 20:41:24 22:19:04 16:41:09 (+1) 输出样例： 04:09:05 12:10:39 14:22:05 题解： 架构： 解决时差与计算飞行用时的问题。考虑地球自转与飞机飞行，我们可以类比小学奥数的小船过河问题。也就是说，我们已知去程与返程的抵达时间与出发时间的差值s1和s2，由于飞行时间=目的地时间-出发地时间+时差（可正可负）而来回的时差一定是互为相反数的，因此我们可以令(s1+s2)/2得到我们需要的飞行时间。 本题的难点其实不在上述逻辑，而在于数据的读入与规格化。我们发现读入的数据是有一定格式的，并且有的数据带+1，有的却不带，因此我们需要为不带+的数据进行人为添加（+0）以使得数据规格化。然后要学会用sscanf来对规格化后的数据进行提取，因为时分秒的时间格式是难以进行加减运算的，所以我们需要设置一个基准，即距离当天0点所过去的秒数。利用我们提取的数据，就可以做到非常好的转换。 #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e using namespace std; int get_second(int h, int m, int s) { return h*3600+60*m+s; } int get_time() { string line; getline(cin, line); int h1, m1, s1, h2, m2, s2, d; if(line.back() != ')') line += \" (+0)\"; sscanf(line.c_str(), \"%d:%d:%d %d:%d:%d (+%d)\", \u0026h1, \u0026m1, \u0026s1, \u0026h2, \u0026m2, \u0026s2, \u0026d); return get_second(h2, m2, s2) - get_second(h1, m1, s1) + 24*60*60*d; } int main() { int n; cin \u003e\u003e n; string line; getline(cin, line); while(n--) { int time = (get_time() + get_time())/2; int hour, minute, second; hour = time/3600; minute = time%3600/60; second = time%60; printf(\"%02d:%02d:%02d\\n\", hour, minute, second); } return 0; } ","date":"2022-03-10","objectID":"/acdaily-8/:3:0","tags":["模拟","规格化输入与输出"],"title":"ACDaily 8","uri":"/acdaily-8/"},{"categories":["ACDaily"],"content":"4.外卖店优先级 “饱了么”外卖系统中维护着 N 家外卖店，编号 1∼N。 每家外卖店都有一个优先级，初始时 (0 时刻) 优先级都为 0。 每经过 1 个时间单位，如果外卖店没有订单，则优先级会减少 1，最低减到 0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 2。 如果某家外卖店某时刻优先级大于 5，则会被系统加入优先缓存中；如果优先级小于等于 3，则会被清除出优先缓存。 给定 T 时刻以内的 M 条订单信息，请你计算 T 时刻时有多少外卖店在优先缓存中。 输入格式 第一行包含 3 个整数 N,M,T。 以下 M 行每行包含两个整数 ts 和 id，表示 ts 时刻编号 id 的外卖店收到一个订单。 输出格式 输出一个整数代表答案。 数据范围 1≤N,M,T≤105, 1≤ts≤T, 1≤id≤N 输入样例： 2 6 6 1 1 5 2 3 1 6 2 2 1 6 2 输出样例： 1 样例解释 6 时刻时，1 号店优先级降到 3，被移除出优先缓存；2 号店优先级升到 6，加入优先缓存。 所以是有 1 家店 (2 号) 在优先缓存中。 题解： 架构： 暴力做法，按照时间推移，对每家店的优先级进行变化和分析，但这样的话时间复杂度为100亿，超时在所难免，所以我们需要对算法进行优化。 考虑到订单量相比店家量理论是更少的，因此大多数店家在大多数时刻都接收不到新订单，也就是说，大多数店家的优先级减小时刻是紧密相连的，也就是以减小块的形式出现，因此我们可以记下在每个时间点每家店最后接收订单的时刻。由此我们就可以非常简单地处理优先级减小问题，将考虑的对象聚焦在获得订单的那些店上，问题就被简化了。 利用成熟的数据结构进行数据的存储 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ccstring\u003e #define x first #define y second using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 100010; int score[N], last[N]; bool st[N]; PII order[N]; int main() { int n, m, T; cin \u003e\u003e n \u003e\u003e m \u003e\u003e T; for(int i = 0; i \u003c m; i++) scanf(\"%d%d\", \u0026order[i].x, \u0026order[i].y); sort(order, order+m); for(int i = 0; i \u003c m;) { int j = i; while(j \u003c m \u0026\u0026 order[i] == order[j]) j++; int t = order[i].x, id = order[i].y, cnt = j-i; i = j; score[id] -= t - last[id] - 1; if(score[id] \u003c 0) score[id] = 0; if(score[id] \u003c= 3) st[id] = false; score[id] += cnt*2; if(score[id] \u003e 5) st[id] = true; last[id] = t; } for(int i = 1; i \u003c= n; i++) { if(last[i] \u003c T) { score[i] -= T-last[i]; if(score[i] \u003c= 3) st[i] = false; } } int res = 0; for(int i = 1; i \u003c= n; i++) { res += st[i]; } cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2022-03-10","objectID":"/acdaily-8/:4:0","tags":["模拟","规格化输入与输出"],"title":"ACDaily 8","uri":"/acdaily-8/"},{"categories":["ACDaily"],"content":"枚举、模拟问题 这类问题通常没有一个非常契合的算法作为计算模板，但通常数据量是有过精心设计的。 我们可以通过以下问题来看一看。 ","date":"2022-03-09","objectID":"/acdaily-7/:0:0","tags":["模拟","枚举"],"title":"ACDaily 7","uri":"/acdaily-7/"},{"categories":["ACDaily"],"content":"1.连续区间段 没有思路时，从暴力做法入手 整体复杂度由每一步的复杂度进行组合后确定 一般可以通过一半的小数字样例 遍历复杂度为O(n)，排序算法复杂度为nlogn 当多重循环内包含大于等于10句话，就属于长代码了。 形成暴力做法的思考闭环后，有想法可以对算法进行优化 逆向思考，什么样的区间满足连号区间，可以发现连号区间等价于区间里最大数-最小数=区间端点差值。有了这样的思路我们就可以进行如下的设计： 先枚举区间左端点，再枚举区间右端点，根据以上思考对方案进行判别。 ","date":"2022-03-09","objectID":"/acdaily-7/:1:0","tags":["模拟","枚举"],"title":"ACDaily 7","uri":"/acdaily-7/"},{"categories":["ACDaily"],"content":"题目描述 在 1∼N 的某个排列中有多少个连号区间呢？ 这里所说的连号区间的定义是： 如果区间 [L,R] 里的所有元素（即此排列的第 L 个到第 R 个元素）递增排序后能得到一个长度为 R−L+1 的“连续”数列，则称这个区间连号区间。 输入格式 第一行是一个正整数 N，表示排列的规模。 第二行是 N 个不同的数字 Pi，表示这 N 个数字的某一排列。 输出格式 输出一个整数，表示不同连号区间的数目。 数据范围 1 ≤ N ≤ 10000, 1 ≤ Pi ≤ N 样例 输入样例1: 4 3 2 4 1 样例1解释: 第一个用例中，有 7 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[2,2],[3,3],[4,4] 输出样例1: 7 输入样例2: 5 3 4 2 5 1 样例2解释: 第二个用例中，有 9 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[1,5],[2,2],[3,3],[4,4],[5,5] 输出样例2: 9 题解 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 10010, INF = 1000000000; int a[N]; int main() { int n; cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; int res = 0; for(int i = 1; i \u003c= n; i++) { int maxv = -INF, minv = INF; for(int j = i; j \u003c= n; j++) { maxv = max(maxv, a[j]); minv = min(minv, a[j]); if(maxv-minv == j-i) res++; } } cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2022-03-09","objectID":"/acdaily-7/:2:0","tags":["模拟","枚举"],"title":"ACDaily 7","uri":"/acdaily-7/"},{"categories":["ACDaily"],"content":"2.递增三元组 题目描述 给定三个整数数组 A=[A1,A2,…AN], B=[B1,B2,…BN], C=[C1,C2,…CN], 请你统计有多少个三元组 (i,j,k) 满足： 1 ≤ i,j,k ≤ N Ai \u003c Bj \u003c Ck 输入格式 第一行包含一个整数 N。 第二行包含 N 个整数 A1,A2,…AN。 第三行包含 N 个整数 B1,B2,…BN。 第四行包含 N 个整数 C1,C2,…CN。 输出格式 一个整数表示答案。 数据范围 1 ≤ N ≤ 10^5, 0 ≤ Ai,Bi,Ci ≤ 10^5 输入样例 3 1 1 1 2 2 2 3 3 3 输出样例 27 题解 首先，我们可以选择一个处理的起点，我们要求满足条件的组合数，考虑到A、C都由B限制，并且观察到数据量为10亿，无法做多重循环，所以我们能且仅能遍历一个数组B。 由于A、B、C中数的比较为相对关系，而数的范围是从0开始的，为了避免特判，我们可以使每个数+1而不改变相对关系 要时刻考虑计算的每个环节，在本题中方案数可能超过int范围，所以我们将计数器变量定义为LL类型 ``` #include \u003ciostream\u003e #include \u003ccstdio\u003e using namespace std; const int N = 100010; int a[N], b[N], c[N]; int sa[N], sc[N]; typedef long long LL; int main() { int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) cin \u003e\u003e a[i], a[i]++; for(int i = 0; i \u003c n; i++) cin \u003e\u003e b[i], b[i]++; for(int i = 0; i \u003c n; i++) cin \u003e\u003e c[i], c[i]++; for(int i = 0; i \u003c n; i++) sa[a[i]]++, sc[c[i]]++; for(int i = 1; i \u003c= N; i++) sa[i] += sa[i-1], sc[i] += sc[i-1]; LL res = 0; for(int i = 0; i \u003c n; i++) { res += (LL)(sa[b[i]-1])*(sc[N]-sc[b[i]]); } cout \u003c\u003c res \u003c\u003c endl; return 0; } ``` ","date":"2022-03-09","objectID":"/acdaily-7/:3:0","tags":["模拟","枚举"],"title":"ACDaily 7","uri":"/acdaily-7/"},{"categories":["ACDaily"],"content":"3.特别数的和 题目描述 小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。 请问，在 1 到 n 中，所有这样的数的和是多少？ 输入格式 共一行，包含一个整数 n。 输出格式 共一行，包含一个整数，表示满足条件的数的和。 数据范围 1≤n≤10000 样例 输入样例： 40 输出样例： 574 题解 本题的关键在于数位的切分，懂得如何利用循环将一个数每一位切下来就可以简单地处理掉这个问题 ``` #include \u003ciostream\u003e #include \u003ccstdio\u003e using namespace std; int main() { int n; cin \u003e\u003e n; int res = 0; for(int i = 1; i \u003c= n; i++) { int last, val = i; while(val) { last = val % 10; if(last == 2 || last == 0 || last == 1 || last == 9) { res += i; break; } val /= 10; } } cout \u003c\u003c res \u003c\u003c endl; return 0; } ``` ","date":"2022-03-09","objectID":"/acdaily-7/:4:0","tags":["模拟","枚举"],"title":"ACDaily 7","uri":"/acdaily-7/"},{"categories":["ACDaily"],"content":"4.错误票据 题目描述 某涉密单位下发了某种票据，并要在年终全部收回。 每张票据有唯一的ID号。 全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。 因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。 你的任务是通过编程，找出断号的ID和重号的ID。 假设断号不可能发生在最大和最小号。 输入格式 第一行包含整数 N，表示后面共有 N 行数据。 接下来 N 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。 输出格式 要求程序输出1行，含两个整数 m,n，用空格分隔。 其中，m表示断号ID， n 表示重号ID。 数据范围 1≤N≤100 样例 blablabla 题解 本题地难点在于数据的读取，剩下的，就是一个简单的模拟了，本题的数据量也不是很大。 在使用getline读取信息时，如果在之前有使用cin读入数据，就要对getline做一次初始化处理，因为cin后会默认将一个空格放在流中，也就是说我们首先要将这个无意义的操作排除。 geline每次可以读取一行信息，只有按下回车才会结束一次读取，它有两个参数，一个是外部输入流cin，一个是空字符串对象line。在使用getline后本次读取的全部信息都会被存储在对象中。 我们可以使用stringstream类中的ssin读取方法，它能够赋予字符串流的特性。即stringstream ssin(line)，进行这样的定义之后，我们就可以使用line \u003e\u003e a[i]以空格作为区分将line中的数据一个个输出。 ``` #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003csstream\u003e #include \u003calgorithm\u003e using namespace std; const int N = 10010; int a[N]; int main() { int k, cnt = 0; string line; cin \u003e\u003e k; getline(cin, line); while(k--) { getline(cin, line); stringstream ssin(line); while(ssin \u003e\u003e a[cnt]) cnt++; } sort(a, a+cnt); int n, m; for(int i = 1; i \u003c cnt; i++) { if(a[i] == a[i-1]) n = a[i]; else if(a[i] \u003e= a[i-1] + 2) m = a[i] - 1; } cout \u003c\u003c m \u003c\u003c \" \" \u003c\u003c n \u003c\u003c endl; return 0; } ``` ","date":"2022-03-09","objectID":"/acdaily-7/:5:0","tags":["模拟","枚举"],"title":"ACDaily 7","uri":"/acdaily-7/"},{"categories":["ACDaily"],"content":"5.回文日期 题目描述 在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。 牛牛习惯用 8 位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2 位代表日期。 显然：一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。 牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。 现在，牛牛想知道：在他指定的两个日期之间（包含这两个日期本身），有多少个真实存在的日期是回文的。 一个 8 位数字是回文的，当且仅当对于所有的 i(1≤i≤8) 从左向右数的第i个数字和第 9−i 个数字（即从右向左数的第 i 个数字）是相同的。 例如： •对于2016年11月19日，用 8 位数字 20161119 表示，它不是回文的。 •对于2010年1月2日，用 8 位数字 20100102 表示，它是回文的。 •对于2010年10月2日，用 8 位数字 20101002 表示，它不是回文的。 输入格式 输入包括两行，每行包括一个8位数字。 第一行表示牛牛指定的起始日期date1，第二行表示牛牛指定的终止日期date2。保证date1和date2都是真实存在的日期，且年份部分一定为4位数字，且首位数字不为0。 保证date1一定不晚于date2。 输出格式 输出共一行，包含一个整数，表示在date1和date2之间，有多少个日期是回文的。 样例 输入样例 20110101 20111231 输出样例 1 题解 本题的第一个关键在于策略的选取，首先年份信息理论上分布于1000与10000之间，构成回文数又只需要前4位，因此我们考虑枚举前4位的所有可能，通过数位切分构成回文数。之后判别该回文数是否位于目标范围内。 之后就需要考虑日期的合理性，即分别对年、月、日进行讨论。月数不能超过1~12，天数不能超过1~31，这是最基本的要求。 最后，考虑日期的现实性，2月的天数取决于该年是否为闰年，我们需要对其做更深入的分类讨论。 ``` #include \u003ciostream\u003e #include \u003ccstdio\u003e using namespace std; int mon[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; bool check(int date) { int year = date/10000; int month = date%10000/100; int day = date%100; if(month \u003c 1 || month \u003e 12) return false; if(month == 2) { int leap = year%4 == 0 \u0026\u0026 year%100 != 0 || year %400 == 0; if(day \u003e mon[1]+leap) return false; } if(day == 0 || month != 2 \u0026\u0026 day \u003e mon[month-1]) return false; return true; } int main() { int date1, date2; cin \u003e\u003e date1 \u003e\u003e date2; int cnt = 0; for(int i = 1000; i \u003c= 9999; i++) { int date = i, x = i; for(int j = 0; j \u003c 4; j++) { date = date*10+x%10; x /= 10; } if(date \u003e= date1 \u0026\u0026 date \u003c= date2 \u0026\u0026 check(date)) cnt++; } cout \u003c\u003c cnt \u003c\u003c endl; return 0; } ``` ","date":"2022-03-09","objectID":"/acdaily-7/:6:0","tags":["模拟","枚举"],"title":"ACDaily 7","uri":"/acdaily-7/"},{"categories":["ACDaily"],"content":"背包问题练习与LeetCode初体验 这两天做题效率低了一些，不过背包是一块难啃的骨头，要集中一些。 ","date":"2022-03-06","objectID":"/acdaily-6/:0:0","tags":["DP","背包问题","LeetCode","字符串拆分与拼接"],"title":"ACDaily 6","uri":"/acdaily-6/"},{"categories":["ACDaily"],"content":"波动数列 观察这个数列： 1 3 0 2 -1 1 -2 … 这个数列中后一项总是比前一项增加2或者减少3，且每一项都为整数。 栋栋对这种数列很好奇，他想知道长度为 n 和为 s 而且后一项总是比前一项增加 a 或者减少 b 的整数数列可能有多少种呢？ 输入格式 共一行，包含四个整数 n,s,a,b，含义如前面所述。 输出格式 共一行，包含一个整数，表示满足条件的方案数。 由于这个数很大，请输出方案数除以 100000007 的余数。 数据范围 1≤n≤1000, −109≤s≤109, 1≤a,b≤106 输入样例： 4 10 2 3 输出样例： 2 样例解释 两个满足条件的数列分别是2 4 1 3和7 4 1 -2。 题解： #include \u003ciostream\u003e using namespace std; const int N = 1010, MOD = 100000007; int f[N][N]; int get_mod(int a, int b) { return (a%b + b) % b; } int main() { int n, s, a, b; cin \u003e\u003e n \u003e\u003e s \u003e\u003e a \u003e\u003e b; f[0][0] = 1; for(int i = 1; i \u003c= n-1; i++) for(int j = 0; j \u003c n; j++) { f[i][j] = (f[i-1][get_mod(j-a*(n-i), n)]+f[i-1][get_mod(j + b*(n-i), n)]) % MOD; } cout \u003c\u003c f[n-1][get_mod(s, n)] \u003c\u003c endl; return 0; } 按照我们在ACDaily 5提到的标准流程，先做好状态表示，再做好状态计算。 根据题意我们要求的是所有方案数，因此状态数组内存的应该是方案数。那么我们要给出的，是哪一类方案数呢。根据题意，我们可以设置一个起点数x，之后的每个数由于只比前一个数大a或少b，我们把它们记作di，表示相对于第i-1项的变化量。 在做了以上数学转换后，我们就可以得到一个等值的表达式。再来看看目的：n个数的序列之和应该是n的倍数，因此，我们可以将问题转化为：序列和s与di组合mod n达到同余要求的所有方案。 所以我们可以用f[i][j]表示前i个d(d1~dn-1)的所有组合同余j的方案数。 接着，我们根据化整为零的思想按照序列最后一项的区别对集合进行划分。观察到最后一项仅有(n-i)*a和-(n-1)*b两种可能，于是我们将这两种情况的方案数相加就可以得到当下情况的方案数。 再经过状态的合并来获得目标方案。 几点要明确的 C++中负数模正数是可以得到负余数的，例如a \u003c 0, b \u003e 0 a%b就属于-(b-1) ~ (b-1)，因此在本题中设计了函数将负余数转化为正余数。 一切从实际出发，考虑各特征的合理范围 特别注意初始化起点的值 由于MOD为9位数，所以对于多数相加取模问题，我们需要一步一步地先做加法再取模，也就是加一个数，取一次模，再加一个数，再取一次模，直到把所有数加完。 ","date":"2022-03-06","objectID":"/acdaily-6/:1:0","tags":["DP","背包问题","LeetCode","字符串拆分与拼接"],"title":"ACDaily 6","uri":"/acdaily-6/"},{"categories":["ACDaily"],"content":"LeetCode初体验 第一次参加LeetCode周赛，有许多不适应的地方，不过参加过了就有了一些了解与体会。 LeetCode系统会默认添加所有C++头文件，这也是很多人喜欢用C++打比赛的原因，因为STL的数据结构集成性非常好。 在代码区，系统会为你提供一个Solution类，并且给出解答该题的函数设计框架，算是一种提示吧。如果需要全局变量，我们就需要设计静态成员，然后初始化；一般变量则可以直接在函数内定义。其实，规范一些，我们的所有变量都应该在数据成员区进行定义。 要多打打这些有时限的算法比赛，激活自己的状态，同时也能意识到自己在哪些地方有不足，是一种很好的反馈。 这次只AC了一道题，与大佬们还有很大差距，冲冲冲。 ","date":"2022-03-06","objectID":"/acdaily-6/:2:0","tags":["DP","背包问题","LeetCode","字符串拆分与拼接"],"title":"ACDaily 6","uri":"/acdaily-6/"},{"categories":["ACDaily"],"content":"Excel表中某个范围内的单元格 概述：给定一个Excel表格区间letter1 i:letter2 j并且'A'\u003c= letter1 \u003c= letter2 \u003c= 'Z', i \u003c= j，要求输出这个范围的所有格子，假如给定的区间为K1:L2,那么我们就应该输出向量[\"K1\", \"K2\", \"L1\", \"L2\"]，可以看到，在满足条件的区域遍历的顺序为由上而下，由左而右。 原题链接可以参考LeetCode.6016 ","date":"2022-03-06","objectID":"/acdaily-6/:3:0","tags":["DP","背包问题","LeetCode","字符串拆分与拼接"],"title":"ACDaily 6","uri":"/acdaily-6/"},{"categories":["ACDaily"],"content":"原始人做法 class Solution { public: vector\u003cstring\u003e cellsInRange(string s) { vector\u003cstring\u003e list; char a[2]; char b[2]; char letter[26]; for(int i = 0; i \u003c 26; i++) letter[i] = i+65; char *str = (char*)s.data(); const char *d = \":\"; char *p; p = strtok(str, d); a[0] = p[0]; b[0] = p[1]; p = strtok(nullptr, d); a[1] = p[0]; b[1] = p[1]; int num1 = b[0]-'0'; int num2 = b[1]-'0'; int letter1 = a[0]-65; int letter2 = a[1]-65; for(int i = letter1; i \u003c= letter2; i++) for(int j = num1; j \u003c= num2; j++) { const char num = j+48; char p[80]; p[0] = letter[i]; p[1] = num; list.insert(list.end(), p); } return list; } }; ","date":"2022-03-06","objectID":"/acdaily-6/:3:1","tags":["DP","背包问题","LeetCode","字符串拆分与拼接"],"title":"ACDaily 6","uri":"/acdaily-6/"},{"categories":["ACDaily"],"content":"STL加持做法 class Solution { public: vector\u003cstring\u003e cellsInRange(string s) { char a = s[0], b = s[3]; int p = s[1] - '0', q = s[4] - '0'; vector\u003cstring\u003e ans; for (char c = a; c \u003c= b; ++c) { for (int d = p; d \u003c= q; ++d) { string t{c, (char)(d + '0')}; ans.push_back(t); } } return ans; } }; STL作用太大了，需要好好学学。 其实STL对于我们学习数据结构也是很有帮助的，以STL数据结构为参照，对应其中的功能来实现我们自己的类应该是一种更好的学法，毕竟我们学习数据结构不是为了在使用时造轮子而是更好地去驾驭已经比较完善的库中的它们，毕竟STL内的数据结构实现比我们要完善的多吧doge。 ","date":"2022-03-06","objectID":"/acdaily-6/:3:2","tags":["DP","背包问题","LeetCode","字符串拆分与拼接"],"title":"ACDaily 6","uri":"/acdaily-6/"},{"categories":["ACDaily"],"content":"从集合角度分析DP问题 ","date":"2022-03-05","objectID":"/acdaily-5/:0:0","tags":["DP","背包问题"],"title":"ACDaily 5","uri":"/acdaily-5/"},{"categories":["ACDaily"],"content":"算法特点 一般问法：最值（价值等属性）、达到某一目标的方向总数 背包问题的本质为组合问题，即在一定条件下从一部分物品中挑选物品；同时也类似于图论的最短路，可以说，DP是一种特殊的图论 暴力做法：方案数量为指数级 化零为整：挖掘不同方案间的共同关系，把有相同关系的元素放在一起 化整为零：把一个集合划分为多个子集，进行分析 解决问题的过程中一定抓住从实际含义出发 具体的分析在下述例题中会有解释 题解的优化可以参考ACDaily 4 ","date":"2022-03-05","objectID":"/acdaily-5/:1:0","tags":["DP","背包问题"],"title":"ACDaily 5","uri":"/acdaily-5/"},{"categories":["ACDaily"],"content":"01背包 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 本题题解具体优化可以参考ACDaily 4，此处借此例讲解动态规划基本的算法架构 ","date":"2022-03-05","objectID":"/acdaily-5/:2:0","tags":["DP","背包问题"],"title":"ACDaily 5","uri":"/acdaily-5/"},{"categories":["ACDaily"],"content":"算法架构：动态规划集合化 状态表示（一般为二维，不可能超时）f[i][j] 集合的思想，f[i][j]表示的并非是j体积背包下对前i个物品进行选择下的价值最大值，而是j体积下对前i个物品进行选择下的所有方案的最大价值（每个物品可选可不选） 属性：min、max、count，即数组中的元素表示最值或方案数 状态计算(化零为整) 集合的划分，划分依据：最后一个不同点。即在限制条件下（确定问题域），按选或不选第i个物品（i个物品中的最后物品）对方案进行划分为A（选i）和B（不选i)集合 要求：不重不漏，每个子集中的元素具有相同共性（都选或没选第i个物品），各子集又能组合成全集 对不选i的集合中（B）所有方案的最大价值进行计算，得到max1 按物品选择是否发生变化，对上述划分包含选择第i个物品的方案（即A方案集合）进行分区，物品i所在区域为不变区，前i-1个物品组成的区域为变化区 寻找变化区中总价值最大的物品选择方案，加上第i个物品的价值，得到最大价值max2 求max(max1, max2),得到整体最大价值 关键在于选择划分方式，例如以下的摘花生与最大子序列长度 ","date":"2022-03-05","objectID":"/acdaily-5/:2:1","tags":["DP","背包问题"],"title":"ACDaily 5","uri":"/acdaily-5/"},{"categories":["ACDaily"],"content":"1. 摘花生 Hello Kitty想摘点花生送给她喜欢的米老鼠。 她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。 地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。 Hello Kitty只能向东或向南走，不能向西或向北走。 问Hello Kitty最多能够摘到多少颗花生。 输入格式 第一行是一个整数T，代表一共有多少组数据。 接下来是T组数据。 每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。 每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。 输出格式 对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。 数据范围 1≤T≤100, 1≤R,C≤100, 0≤M≤1000 输入样例： 2 2 2 1 1 3 4 2 3 2 3 4 1 6 5 输出样例： 8 16 题解： #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ccstring\u003e using namespace std; const int N = 55, MOD = 1000000007; int w[N][N]; int f[N][N][13][14]; int main() { int n, m, k; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) { cin \u003e\u003e w[i][j]; w[i][j]++; // 调整整体价值范围 } f[1][1][0][0] = 1; f[1][1][1][w[1][1]] = 1; // 初始化 for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) { if(i == 1 \u0026\u0026 j == 1) continue; // 起点已进行过初始化 for(int u = 0; u \u003c= k; u++) for(int v = 0; v \u003c= 13; v++) { int \u0026val = f[i][j][u][v]; val = (val + f[i-1][j][u][v]) % MOD; val = (val + f[i][j-1][u][v]) % MOD; if(u \u003e 0 \u0026\u0026 v == w[i][j]) { for(int c = 0; c \u003c v; c++) { val = (val + f[i-1][j][u-1][c]) % MOD; val = (val + f[i][j-1][u-1][c]) % MOD; } } } } int res = 0; for(int c = 0; c \u003c= 13; c++) res = (res + f[n][m][k][c]) % MOD; cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2022-03-05","objectID":"/acdaily-5/:3:0","tags":["DP","背包问题"],"title":"ACDaily 5","uri":"/acdaily-5/"},{"categories":["ACDaily"],"content":"2. 最长上升子序列 给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式 第一行包含整数 N。 第二行包含 N 个整数，表示完整序列。 输出格式 输出一个整数，表示最大长度。 数据范围 1≤N≤1000， −109≤数列中的数≤109 输入样例： 7 3 1 2 1 8 5 6 输出样例： 4 题解： #include \u003ciostream\u003e using namespace std; const int N = 1010; int n; int w[N], f[N]; int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) cin \u003e\u003e w[i]; int mx = 1; // 找出所计算的f[i]之中的最大值，边算边找 for (int i = n; i \u003e= 0; i--) { f[i] = 1; // 设f[i]默认为1，找不到前面数字小于自己的时候就为1 for (int j = i+1; j \u003c n; j++) { if (w[i] \u003c w[j]) f[i] = max(f[i], f[j] + 1); // 这种写法是f[j]已经更新过的正常写法 } mx = max(mx, f[i]); } cout \u003c\u003c mx \u003c\u003c endl; return 0; } ","date":"2022-03-05","objectID":"/acdaily-5/:4:0","tags":["DP","背包问题"],"title":"ACDaily 5","uri":"/acdaily-5/"},{"categories":["ACDaily"],"content":"3. 地宫寻宝 X 国王有一个地宫宝库，是 n×m 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。 地宫的入口在左上角，出口在右下角。 小明被带到地宫的入口，国王要求他只能向右或向下行走。 走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。 当小明走到出口时，如果他手中的宝贝恰好是 k 件，则这些宝贝就可以送给小明。 请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k 件宝贝。 输入格式 第一行 3 个整数，n,m,k，含义见题目描述。 接下来 n 行，每行有 m 个整数 Ci 用来描述宝库矩阵每个格子的宝贝价值。 输出格式 输出一个整数，表示正好取 k 个宝贝的行动方案数。 该数字可能很大，输出它对 1000000007 取模的结果。 数据范围 1≤n,m≤50, 1≤k≤12, 0≤Ci≤12 输入样例1： 2 2 2 1 2 2 1 输出样例1： 2 输入样例2： 2 3 2 1 2 3 2 1 5 输出样例2： 14 题解： #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ccstring\u003e using namespace std; const int N = 55, MOD = 1000000007; int w[N][N]; int f[N][N][13][14]; int main() { int n, m, k; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) { cin \u003e\u003e w[i][j]; w[i][j]++; // 调整整体价值范围 } f[1][1][0][0] = 1; f[1][1][1][w[1][1]] = 1; // 初始化 for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) { if(i == 1 \u0026\u0026 j == 1) continue; // 起点已进行过初始化 for(int u = 0; u \u003c= k; u++) for(int v = 0; v \u003c= 13; v++) { int \u0026val = f[i][j][u][v]; val = (val + f[i-1][j][u][v]) % MOD; val = (val + f[i][j-1][u][v]) % MOD; if(u \u003e 0 \u0026\u0026 v == w[i][j]) { for(int c = 0; c \u003c v; c++) { val = (val + f[i-1][j][u-1][c]) % MOD; val = (val + f[i][j-1][u-1][c]) % MOD; } } } } int res = 0; for(int c = 0; c \u003c= 13; c++) res = (res + f[n][m][k][c]) % MOD; cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2022-03-05","objectID":"/acdaily-5/:5:0","tags":["DP","背包问题"],"title":"ACDaily 5","uri":"/acdaily-5/"},{"categories":["ACDaily"],"content":"不简单DP ","date":"2022-03-04","objectID":"/acdaily-4/:0:0","tags":["DP","背包问题"],"title":"ACDaily 4","uri":"/acdaily-4/"},{"categories":["ACDaily"],"content":"01背包问题 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0\u003cN,V≤1000 0\u003cvi,wi≤1000 输入样例 4 5 1 2 2 4 3 4 4 5 输出样例： 8 题解: 这道题若使用暴力做法，可以将题意转化为：给定n位二进制序列（即n个物品，若该位为1，则表示选择该物品，反之不选择），每一位对应一个价值和一个体积，枚举所有所有可能的组合，先判断能不能装进背包，若能装，则计算总价值，更新当前最大价值，反之，不更新最大价值，最后输出最大价值即可。通过分析，我们可以发现这种做法的复杂度为指数级别，超时不可避免，因此我们需要优化算法。 1.用二维数组做动态决策 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int v[N], w[N], f[N][N]; // f数组记录的是j体积下前i个物品的最大价值 int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 记录物品的个数和背包的容积 for(int i = 1; i \u003c= n; i++) cin \u003e\u003e v[i] \u003e\u003e w[i]; // 初始化物品体积和价值 for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) { if(j \u003c v[i]) f[i][j] = f[i-1][j]; // 难点在于为什么判断j \u003c v[i]就可以，因为前i-1间物品是可选可不选的 else{ f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i]); } } cout \u003c\u003c f[n][m] \u003c\u003c endl; return 0; } 本方法的关键在于构造j体积背包下的i个物品的最大价值数组f[N][N]。那么为什么要做这样的假设呢，因为我们最终要求的是背包容量为j的i个物品的最大价值，由递推的思想，j体积背包下前i个物品的最大价值可以由前i-1个物品的最大价值来推导，因此我们可以从最原始的状态出发，不断增加物品数量，在每个物品数量i下，背包的体积j从1开始增长到m，通过对这些情况进行依次判断与选择来确定j体积背包下前i个物品的最大价值。 2.优化：用一维数组做动态决策 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e using namespace std; const int N = 1010; int v[N], w[N], f[N]; // 本方法中的假设与一般方法相同，使用降维的方法，将一些冗余的数值剔除了（可以单步模拟之后的遍历来观察） int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 记录物品的个数和背包的容积 for(int i = 1; i \u003c= n; i++) cin \u003e\u003e v[i] \u003e\u003e w[i]; // 初始化物品体积和价值 for(int i = 1; i \u003c= n; i++) { for(int j = m; j \u003e= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]); // 这种写法相对于一般写法将一些无法更新的位置略过了 } cout \u003c\u003c f[m] \u003c\u003c endl; return 0; } 使用该种优化后，可以省略掉j与v[i]的判断语句，优化循环的终止条件。但要注意j为逆序遍历，这样做的原因是防止当前最大价值计算时需要用到的之前最大价值被污染，这一点也可以通过简单的模拟来实现。 3.输入优化 #include\u003cbits/stdc++.h\u003e using namespace std; const int MAXN = 1005; int f[MAXN]; // int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) { int v, w; cin \u003e\u003e v \u003e\u003e w; // 边输入边处理 for(int j = m; j \u003e= v; j--) f[j] = max(f[j], f[j - v] + w); } cout \u003c\u003c f[m] \u003c\u003c endl; return 0; } 由于两个循环皆有边读入边处理的特性，因此我们可以将这两个循环进行一个合并，减小语句长度。 以上就是对该类问题初步理解而做出的阐述，后续再遇到此类问题时会对内容进行一个更清晰的重构。 对此问题更好的解释可以参考状态转移方程的解释。 ","date":"2022-03-04","objectID":"/acdaily-4/:1:0","tags":["DP","背包问题"],"title":"ACDaily 4","uri":"/acdaily-4/"},{"categories":["ACDaily"],"content":"二分与前缀和的练习 ","date":"2022-03-02","objectID":"/acdaily-2/:0:0","tags":["二分与前缀和"],"title":"ACDaily 2","uri":"/acdaily-2/"},{"categories":["ACDaily"],"content":"分巧克力 儿童节那天有 K位小朋友到小明家做客。 小明拿出了珍藏的巧克力招待小朋友们。 小明一共有 N 块巧克力，其中第 ii 块是 Hi×Wi 的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。 切出的巧克力需要满足： 形状是正方形，边长是整数 大小相同 例如一块 6×6 的巧克力可以切出 66 块 2×2 的巧克力或者 2 块 3×3 的巧克力。 当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 输入格式 第一行包含两个整数 N 和 K。 以下 N 行每行包含两个整数 Hi 和 Wi。 输入保证每位小朋友至少能获得一块 1×1 的巧克力。 输出格式 输出切出的正方形巧克力最大可能的边长。 数据范围 1≤N,K≤105 1≤Hi,Wi≤105 输入样例： 2 10 6 5 5 6 输出样例： 2 题解 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ccstring\u003e using namespace std; int n, k; const int N = 100010; int w[N], h[N]; bool check(int a) // 判断条件 { int num = 0; for(int i = 0; i \u003c n; i++){ num += (w[i]/a)*(h[i]/a); // 直接去掉长度不够的巧克力，同时当巧克力满足条件也可以对能分成的小巧克力数做计算。 if(num \u003e= k) return true; // 若满足条件了，直接返回成立 } return false; } int main() { cin \u003e\u003e n \u003e\u003e k; for(int i = 0; i \u003c n; i++) cin \u003e\u003e w[i] \u003e\u003e h[i]; int l = 0, r = 1e5; while(l \u003c r){ int mid = (l + r + 1) \u003e\u003e 1; // 所求目标值为红色区域右端 if(check(mid)) l = mid; // 红色区域更新 else r = mid - 1; } cout \u003c\u003c r; return 0; } 二分有点忘了，复习复习 ","date":"2022-03-02","objectID":"/acdaily-2/:1:0","tags":["二分与前缀和"],"title":"ACDaily 2","uri":"/acdaily-2/"},{"categories":["ACDaily"],"content":"激光炸弹 地图上有 N 个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。 注意：不同目标可能在同一位置。 现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y 轴平行。 求一颗炸弹最多能炸掉地图上总价值为多少的目标。 输入格式 第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。 接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。 输出格式 输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。 数据范围 0≤R≤109 0\u003cN≤10000, 0≤Xi,Yi≤5000 0≤Wi≤1000 输入样例： 2 1 0 0 1 1 1 1 输出样例： 1 题解 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 5010; int p, q; int s[N][N]; int main() { int n, R; cin \u003e\u003e n \u003e\u003e R; R = min(5001, R); p = q = R; while(n--){ int x, y, w; cin \u003e\u003e x \u003e\u003e y \u003e\u003e w; x++, y++; p = max(x, p); q = max(y, q); s[x][y] += w; } for(int i = 1; i \u003c= p; i++) for(int j = 1; j \u003c= q; j++) s[i][j] += s[i-1][j] + s[i][j-1] - s[i-1][j-1]; int sum = 0; for(int i = R; i \u003c= p; i++) for(int j = R; j \u003c= q; j++){ sum = max(sum, s[i][j]-s[i-R][j]-s[i][j-R]+s[i-R][j-R]); } cout \u003c\u003c sum; return 0; } 巧妙利用炸弹位置的合理性处理遍历范围减少遍历范围能够优化程序运行速度 二维前缀和的一个非常好的案例 ","date":"2022-03-02","objectID":"/acdaily-2/:2:0","tags":["二分与前缀和"],"title":"ACDaily 2","uri":"/acdaily-2/"},{"categories":["ACDaily"],"content":"K倍区间 给定一个长度为 N 的数列，A1,A2,…AN，如果其中一段连续的子序列 Ai,Ai+1,…Aj 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。 你能求出数列中总共有多少个 K 倍区间吗？ 输入格式 第一行包含两个整数 N 和 K。 以下 N 行每行包含一个整数 Ai。 输出格式 输出一个整数，代表 K 倍区间的数目。 数据范围 1≤N,K≤100000, 1≤Ai≤100000 输入样例： 5 2 1 2 3 4 5 输出样例： 6 题解 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; typedef long long LL; const int N = 100010; LL s[N], cnt[N]; int main() { int n, k; cin \u003e\u003e n \u003e\u003e k; LL res = 0; cnt[0]++; for(int i = 1; i \u003c= n; i++){ cin \u003e\u003e s[i]; s[i] += s[i-1]; res += cnt[s[i]%k]; cnt[s[i]%k]++; } printf(\"%lld\", res); return 0; } 本题最关键的一步在于利用前缀和将区间和表示为前缀和的差的形式，这样的话，如果区间和是k的倍数，那么两个前缀和应该是同余的，也就是说如果前缀和模k的余数相同，那么二者之间的差值一定是k的倍数。运用这种方法，有以下效果： $$ O(n^2)-\u003eO(n) $$ 拒绝溢出。 ","date":"2022-03-02","objectID":"/acdaily-2/:3:0","tags":["二分与前缀和"],"title":"ACDaily 2","uri":"/acdaily-2/"},{"categories":["ACDaily"],"content":"前缀和模板题 ","date":"2022-03-01","objectID":"/acdaily-1/:0:0","tags":["前缀和"],"title":"ACDaily 1","uri":"/acdaily-1/"},{"categories":["ACDaily"],"content":"1. 前缀和 输入一个长度为 n 的整数序列。 接下来再输入 m 个询问，每个询问输入一对 l,r。 对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。 输入格式 第一行包含两个整数 n和 m。 第二行包含 n 个整数，表示整数数列。 接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。 输出格式 共 m行，每行输出一个询问的结果。 数据范围 1≤l≤r≤n, 1≤n,m≤100000 −1000≤数列中元素的值≤1000 输入样例： 5 3 2 1 3 6 4 1 2 1 3 2 4 输出样例： 3 6 10 题解 #include \u003ciostream\u003e using namespace std; const int N = 100010; int a[N], s[N]; int main() { int n, m, num, l, r; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++){ cin \u003e\u003e num; a[i] = num; } for(int i = 1; i \u003c= n; i++) s[i] = s[i-1] + a[i]; while(m--){ cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c s[r] - s[l-1] \u003c\u003c endl; } return 0; } 不构建前缀和数组只能通过6个数据 使用C输入输出能够大大提高程序运行速度 ","date":"2022-03-01","objectID":"/acdaily-1/:1:0","tags":["前缀和"],"title":"ACDaily 1","uri":"/acdaily-1/"},{"categories":["ACDaily"],"content":"2. 子矩阵和 输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。 对于每个询问输出子矩阵中所有数的和。 输入格式 第一行包含三个整数 n，m，q。 接下来 n 行，每行包含 m 个整数，表示整数矩阵。 接下来 q 行，每行包含四个整数 x1,y1,x2,y2表示一组询问。 输出格式 共 q 行，每行输出一个询问的结果。 数据范围 1≤n,m≤1000, 1≤q≤200000 1≤x1≤x2≤n 1≤y1≤y2≤m −1000≤矩阵内元素的值≤1000 输入样例： 3 4 3 1 7 2 4 3 6 2 8 2 1 2 3 1 1 2 2 2 1 3 4 1 3 3 4 输出样例： 17 27 21 题解 #include \u003ciostream\u003e #include \u003ccstdio\u003e using namespace std; const int N = 1010; int a[N][N], s[N][N]; int main() { int n, m, q, k; int x1, y1, x2, y2; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++){ cin \u003e\u003e k; a[i][j] = k; } for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++){ s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]; } while(q--){ cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; cout \u003c\u003c s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1] \u003c\u003c endl; } return 0; } 在构建前缀和时要注意运用递推的思想，不能陷入循环 ","date":"2022-03-01","objectID":"/acdaily-1/:2:0","tags":["前缀和"],"title":"ACDaily 1","uri":"/acdaily-1/"},{"categories":["ACDaily"],"content":"双指针算法、BFS与图论 ","date":"2022-03-01","objectID":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/:0:0","tags":["双指针","宽搜","图论"],"title":"双指针、BFS和图论","uri":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"},{"categories":["ACDaily"],"content":"1.双指针算法 通常考虑遍历所有区间时会用到这种算法，比如需要枚举一段时间内的所有定长时间段，由于在时间轴上两个时间段会有大部分位置的重合，因此每次可以减少一个头部时刻，增加一个尾部时刻来实现时间段的时序枚举。实际上，这个算法是对类似以下语法结构的优化： for(int i = 0; i \u003c n; i++) for(int j = 0; j \u003c k; j++) ","date":"2022-03-01","objectID":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/:1:0","tags":["双指针","宽搜","图论"],"title":"双指针、BFS和图论","uri":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"},{"categories":["ACDaily"],"content":"eg.日志统计 小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N 行。 其中每一行的格式是： ts id 表示在 ts 时刻编号 id 的帖子收到一个”赞”。 现在小明想统计有哪些帖子曾经是”热帖”。 如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，小明就认为这个帖子曾是”热帖”。 具体来说，如果存在某个时刻 T 满足该帖在 [T,T+D) 这段时间内(注意是左闭右开区间)收到不少于 K 个赞，该帖就曾是”热帖”。 给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。 输入格式 第一行包含三个整数 N,D,K。 以下 N 行每行一条日志，包含两个整数 ts 和 id。 输出格式 按从小到大的顺序输出热帖 id。 每个 id 占一行。 数据范围 1≤K≤N≤105, 0≤ts,id≤105, 1≤D≤10000 题解： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003ccstdio\u003e #define x first #define y second using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 100010; int n, d, k; PII logs[N]; bool st[N]; int cnt[N]; int main() { scanf(\"%d%d%d\", \u0026n, \u0026d, \u0026k); for(int i = 0; i \u003c n; i++) scanf(\"%d%d\", \u0026logs[i].x, \u0026logs[i].y); sort(logs, logs + n); for(int i = 0, j = 0; i \u003c n; i++) { int id = logs[i].y; cnt[id]++; while(logs[i].x - logs[j].x \u003e= d) { cnt[logs[j].y]--; j++; } if(cnt[id] \u003e= k) st[id] = true; } for(int i = 0; i \u003c= 100000; i++) { if(st[i]) cout \u003c\u003c i \u003c\u003c endl; } return 0; } ","date":"2022-03-01","objectID":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/:1:1","tags":["双指针","宽搜","图论"],"title":"双指针、BFS和图论","uri":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"},{"categories":["ACDaily"],"content":"2.宽度优先搜索BFS 一组数，整合为数状，使用队列来辅助操作，从树根出发，若队列非空，取队头，用队头的两个儿子来入队更新队列，直至队列为空，这样就对树进行了宽度优先搜索。 bfs常用于迷宫问题，bfs相对于dfs可以找到一条最短路径 ","date":"2022-03-01","objectID":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/:2:0","tags":["双指针","宽搜","图论"],"title":"双指针、BFS和图论","uri":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"},{"categories":["ACDaily"],"content":"eg.献给阿尔吉侬的花束 阿尔吉侬是一只聪明又慵懒的小白鼠，它最擅长的就是走各种各样的迷宫。 今天它要挑战一个非常大的迷宫，研究员们为了鼓励阿尔吉侬尽快到达终点，就在终点放了一块阿尔吉侬最喜欢的奶酪。 现在研究员们想知道，如果阿尔吉侬足够聪明，它最少需要多少时间就能吃到奶酪。 迷宫用一个 R×C 的字符矩阵来表示。 字符 S 表示阿尔吉侬所在的位置，字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行。 阿尔吉侬在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。 输入格式 第一行是一个正整数 T，表示一共有 T 组数据。 每一组数据的第一行包含了两个用空格分开的正整数 R 和 C，表示地图是一个 R×C 的矩阵。 接下来的 R 行描述了地图的具体内容，每一行包含了 C 个字符。字符含义如题目描述中所述。保证有且仅有一个 S 和 E。 输出格式 对于每一组数据，输出阿尔吉侬吃到奶酪的最少单位时间。 若阿尔吉侬无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。 每组数据的输出结果占一行。 数据范围 1\u003cT≤10, 2≤R,C≤200 输入样例： 3 3 4 .S.. ###. ..E. 3 4 .S.. .E.. …. 3 4 .S.. ..E. 输出样例： 5 1 oop! 题解： #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003ccstdio\u003e #include \u003cqueue\u003e #define x first #define y second using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 210; int t, r, c; char g[N][N]; int dist[N][N]; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int bfs(PII start, PII end) { queue\u003cPII\u003e q; memset(dist, -1, sizeof dist); dist[start.x][start.y] = 0; q.push(start); while(q.size()) { auto t = q.front(); q.pop(); for(int i = 0; i \u003c 4; i++) { int x = t.x + dx[i], y = t.y + dy[i]; if(x \u003c 0 || x \u003e= r || y \u003c 0 || y \u003e= c) continue; if(g[x][y] == '#') continue; if(dist[x][y] != -1) continue; dist[x][y] = dist[t.x][t.y] + 1; if(make_pair(x, y) == end) return dist[x][y]; q.push({x, y}); } } return -1; } int main() { scanf(\"%d\", \u0026t); while(t--) { scanf(\"%d%d\", \u0026r, \u0026c); for(int i = 0; i \u003c r; i++) scanf(\"%s\", g[i]); PII start, end; for(int i = 0; i \u003c r; i++) for(int j = 0; j \u003c c; j++) { if(g[i][j] == 'S') start = {i, j}; if(g[i][j] == 'E') end = {i, j}; } int distance = bfs(start, end); if(distance == -1) { cout \u003c\u003c \"oop!\" \u003c\u003c endl; continue; } printf(\"%d\\n\", distance); } return 0; } ","date":"2022-03-01","objectID":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/:2:1","tags":["双指针","宽搜","图论"],"title":"双指针、BFS和图论","uri":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"},{"categories":["ACDaily"],"content":"3.图论 判重数组使得每个点最多只会被遍历一次 ","date":"2022-03-01","objectID":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/:3:0","tags":["双指针","宽搜","图论"],"title":"双指针、BFS和图论","uri":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"},{"categories":["ACDaily"],"content":"eg.交换瓶子 有 N 个瓶子，编号 1∼N，放在架子上。 比如有 5 个瓶子： 2 1 3 5 4 要求每次拿起 2 个瓶子，交换它们的位置。 经过若干次后，使得瓶子的序号为： 1 2 3 4 5 对于这么简单的情况，显然，至少需要交换 2 次就可以复位。 如果瓶子更多呢？你可以通过编程来解决。 输入格式 第一行包含一个整数 N，表示瓶子数量。 第二行包含 N 个整数，表示瓶子目前的排列状况。 输出格式 输出一个正整数，表示至少交换多少次，才能完成排序。 数据范围 1≤N≤10000, 输入样例1： 5 3 1 2 5 4 输出样例1： 3 输入样例2： 5 5 4 3 2 1 输出样例2： 2 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int N = 10010; int w[N]; bool st[N]; int main() { int n; cin \u003e\u003e n; for (int i = 1; i \u003c= n; i ++ ) cin \u003e\u003e w[i]; int cnt = 0; for(int i = 1; i \u003c= n; i++) { if(!st[i]) { cnt++; for(int j = i; !st[j]; j = w[j]) st[j] = true; } } printf(\"%d\", n - cnt); return 0; } ","date":"2022-03-01","objectID":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/:3:1","tags":["双指针","宽搜","图论"],"title":"双指针、BFS和图论","uri":"/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"},{"categories":["Go Project"],"content":" 摘要：贪吃蛇是我们从小玩到大的小游戏，本次实训以此为载体，将Go语言的基本语法与使用规范进行展示。同时在报告中也会对Go语言的独有特性进行介绍。 一.项目分析 (一)贪吃蛇玩法： 在一定区域内通过上下左右方向键控制蛇的方向，寻找食物，吃到食物后获得积分，并且蛇的身子变长，蛇不能碰墙与自己的身体。 (二)项目模块分析： 1.蛇模块 Ø 初始化蛇（出生） Ø 蛇移动 Ø 碰撞食物，长度改变 Ø 碰撞墙或自己，蛇死亡 2.食物模块 Ø 食物产生 Ø 食物消失 3.游戏控制 Ø 控制键盘输入 Ø 游戏流程 4.游戏显示 Ø 游戏地图显示 （三）流程初定 基于以上的项目模块分析，我们可以初步确定项目实现的基本流程，在之后的每一步再不断优化下一步的处理。具体的流程如下：构建地图、食物类、蛇类 -\u003e 图形显示器 -\u003e 初始化地图信息 -\u003e 初始化蛇信息 -\u003e 设计食物随机产生器-\u003e 设计游戏逻辑 -\u003e 设计主程序。 二.项目的实现 文件结构： $GOPATH: src\\she.go $GOROOT: src\\Clib\\Clib.go （一）地图、蛇类、食物类的构造 1.地图设置 作为一个合理的贪吃蛇游戏，同时考虑我们的贪吃蛇小游戏是在命令行中实现的。因此我们考虑全局声明地图的长和高，且将它们初始化为20。这样我们就可以在main包中的任意位置合理地调用它们。 Package main Import … const WIDE int = 20 // 设置布局 const HIGH int = 20 2.蛇类与食物类设置 作为一款贪吃蛇小游戏，主角当然是我们的小蛇。小蛇有它的长度size，有运动方向dir（小蛇是有头有尾的）。那么，要将小蛇的长度与方向这两个外部显示属性进行修改并显示，就需要引入一个能够对小蛇位置进行控制的数据结构——数组。这个数组中存放着小蛇每一节的位置坐标，考虑到小蛇的运动自由性，我们可以将数组的容量设置为地图的大小即20*20 = 400。 作为贪吃蛇小游戏的次角——食物就没有那么多的信息，不过在后期可以对它的ui进行一个美化。 type Snake struct{ size int dir byte pos [WIDE*HIGH]Position } type Food struct{ Position } （二）设计图形显示器 定义好以上静态信息，如果不对它们进行外部显示，便失去了意义。考虑到我们最终设计出来的小蛇与食物的位置是在不断变化的，但每一次变化的位置可以用光标来控制，因此我们考虑用cgo即c与go语言进行混合编程来实现这一功能，因为c语言标准库中有简单的函数来实现命令行光标的移动。我们要做的仅仅是做一个接口，使得在Go中也能调用的这些c函数。 首先，我们需要自行构建一个包，在这里我们命名为Clib。在GoRoot目录的src文件下新建一个文件夹并命名为Clib，然后在它的内部创建一个Go文件，写入以下信息： package Clib /* #include \u003cwindows.h\u003e #include \u003cconio.h\u003e // 使用了WinAPI来移动控制台的光标 void gotoxy(int x, int y) { COORD c; c.X = x, c.Y = y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), c); } // 从键盘获取一次按键，但不显示到控制台 int direct() { return _getch(); } //去掉控制台光标 void hideCursor() { CONSOLE_CURSOR_INFO cci; cci.bVisible = FALSE; cci.dwSize = sizeof(cci); SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), \u0026cci); } */ import \"C\" //设置控制台光标位置 func GotoPosition(X int, Y int) { //调用C语言函数 C.gotoxy(C.int(X), C.int(Y)) // go类型转换 } //无显获取键盘输入的字符 func Direction() (key int) { key = int(C.direct()) return } //设置控制台光标隐藏 func HideCursor() { C.hideCursor() } 注意包头要注明package Clib，之后在Clib文件夹中新建的Go文件也是如此，这类似于一个归属标识，不可缺少。 /与/包裹的部分是C语言，也是Go中可以调用的函数的一个本源映射， 标准的头文件引入与函数定义都是需要的，与C中语法相同。一个要注意的点是import “C”与上面的C语言引用说明间是不能有空行的，否则在之后的主文件包调用中会报错；还有Go函数的名称一定要大写，这与后期调用有密切关系。通过以上两点我们可以看到Go语言对格式的高规范、高要求。 设计好我们需要的包后，就需要在主文件中调用采用使用其中的函数。 import ( \"Clib\" \"fmt\" \"math/rand\" \"os\" \"time\" ) 回到正题，我们需要将命令行光标移动到蛇与食物的每个位置来设置它们的ui，因此我们在这里用的是用C设计的gotoxy函数与Go设计的GotoPosition函数。在主文件中，我们定义函数showUI，接口设置为目标（蛇或食物）的位置坐标与需要设置的ui图形。 func ShowUI(X int, Y int, ui byte){ // 找到对应坐标点光标位置 Clib.GotoPosition(X*2+2,Y+2) // 避免蛇移动影响棋盘边界 // 绘制图形 fmt.Fprintf(os.Stderr, \"%c\", ui) } (三)初始化地图信息 地图的初始化是简单的，我们仅需将一个方框打印出来，由于篇幅有限这里只做出来它的简化图： func MapInit(){ fmt.Fprintln(os.Stderr,` #------# | | | | #------# `) } 可以想象一下，实际上水平方向有40个“-”，竖直方向有20个“|”。 这里采用了一个特殊函数Fprintln，对比ShowUI中的Fprintf，我们可以看到其中的相似与差别: Fprintf Fprintf 根据 format 参数生成格式化的字符串并写入 w 。返回写入的字节数和遇到的任何错误。 Fprintln Fprintln 采用默认格式将其参数格式化并写入 w 。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。返回写入的字节数和遇到的任何错误。 **(**四)初始化蛇信息 1.初始化蛇的长度、方向与位置，并绘制初始形态 通常，贪吃蛇的开端是地图的中心，长度为2（包括一头一尾），并且头朝右，尾与头在一条水平面上，我们的游戏也是如此。 s.size = 2 // 一头一尾 s.dir = 'R' //初始化方向 用UDLR做上下左右 s.pos[0].X = WIDE/2 s.pos[0].Y = HIGH/2 s.pos[1].X = WIDE/2 - 1 s.pos[1].Y = HIGH/2 for i := 0; i \u003c s.size; i++{ var ui byte if i == 0{ ui = '@' } else{ ui = '*' } ShowUI(s.pos[i].X, s.pos[i].Y, ui) } 2.设置蛇方向的调整方式 考虑到玩家在游戏中唯一的操作就是不断改变蛇的移动方向，那么我们就需要建立按键与方向之间的联系。在本模块的设计中需要查找ASCII码与字符间的对应关系。“WSAD”是我们玩游戏时常用的按键，因此我们将它们与方向“上下左右”建立关系，但有时候用户可能会忽视它们的键盘大写设置，或者因外界因素导致某些键位损坏，因此我们也将”wsad”与”udrl”加入了设计。 go func() { for { switch Clib.Direction() { //方向上 W|w|↑ case 83, 115, 80: s.dir = 'U' //方向左 case 65, 97, 75: s.dir = 'L' //方向右 case 100, 68, 77: s.dir = 'R' //方向下 case 72, 87, 119: s.dir = 'D' //暂停 空格键 case 32: s.dir = 'P' } } }() // 特殊的独立函数 这是一个特殊的函数，它独立于main，在程序运行过程中始终保持生效状态。 （五）设计食物随机产生器 由于贪吃蛇中的食物是随机产生的，我们需要赋予食物的位置一个随机性。但Go的rand包在边界范围内产生的随机种子不是随机的，因此我们需要在main中加入混淆种子来实现随机性。 func RandomFood(){ food.X = rand.Intn(WIDE)+1 // 直接写起不到随机的效果,这是go的一个缺点 food.Y = rand.Intn(HIGH)+1 ShowUI(food.X, food.Y, 's') } // 设置一个随机种子，用作混淆 rand.Seed(time.Now().UnixNano()) 注意函数定义在main外，混淆种子定义在main内。 （六）设置游戏逻辑 在游戏开始时，我们就可以对贪吃蛇的方向进行调整，我们在之前已经对键位与贪吃","date":"2022-02-18","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%B4%AA%E5%90%83%E8%9B%87/:0:0","tags":["Go"],"title":"Go语言实现贪吃蛇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%B4%AA%E5%90%83%E8%9B%87/"},{"categories":null,"content":"About Me","date":"2021-08-02","objectID":"/about/","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"关于本人 ID：林知，“千木成林，知行合一”。 始终秉持的一种态度——“Life is a beautiful story”，热爱你的生活~~（有点鸡汤的味道哈哈，不过却很真实）。 头像这东西对于我来说是一种心性的体现吧，所以从某种意义上说可以从我的头像变化历程看出我的成长🧐。 SHUer，CS爱好者。 在成长的路上努力成为一名合格的软件工程师与终身学习者，目标是全栈 ( •̀ ω •́ )✧. ","date":"2021-08-02","objectID":"/about/:1:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"关于爱好 中度颜控中二青年，晚睡早起养生学家，始终在探寻摸🐟与反摸🐟的真谛. 前MOBA、三国杀重度玩家，舟批一枚🐱‍🏍. 后摇、电音、民谣、华语流行等多风格音乐爱好者，节奏派，可以来找我网抑 doge. 平时话不多，但一旦聊开就停不下来哈哈，欢迎来找我唠嗑 (●’◡’●). ","date":"2021-08-02","objectID":"/about/:2:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":["documentation"],"content":"探索 Hugo - FeelIt 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"/theme-documentation-basics/","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - FeelIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.94.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入 一些图像资源使用的是0.94.0中引入的webp, 本主题只支持高于 0.94.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 安装主题 FeelIt 主题的仓库是: https://github.com/khusika/FeelIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/khusika/FeelIt.git themes/FeelIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/khusika/FeelIt.git themes/FeelIt ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 基础配置 以下是 FeelIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"FeelIt\" [params] # FeelIt 主题版本 version = \"1.0.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/khusika/FeelIt/issues/158) noClasses = false 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 配置 ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, FeelIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # FeelIt 主题版本 version = \"1.0.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 是否启用 CSS 和 JS 源映射 SourceMap = true # PWA config [params.pwa] # whether to enable PWA support enable = true # service-worker version version = \"1.0.1\" # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"FeelIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 是否显示RSS图标 rss = true # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # # 关于页面配置 [params.about] # 是否启用关于页面的配置文件 # 依赖于取决于 .Site.Params.home.profile.enable enable = true # 是否启用参数布局 param = true # 参数布局的标题 paramTitle = \"个人信息\" # 您网站的一般描述 # 可以用markdown样式写 description = \"[FeelIt](https://github.com/khusika/FeelIt) 是一个由 [Khusika](https://khusika.dev) 开发的**简洁**、**优雅**且**高效**的 [Hugo](https://gohugo.io/) 博客主题。 它的原型基于 [LoveIt 主题](https://github.com/dillonzq/LoveIt), [LeaveIt 主题](https://github.com/liuzc/LeaveIt), 和 [KeepIt 主题](https://github.com/Fastbyte01/KeepIt)。\" # 你的状态描述 [[params.about.status]] faIcon = \"fas fa-building\" title = \"公司\" desc = \"FeelIt\" [[params.about.status]] faIcon = \"fas fa-briefcase fa-fw\" title = \"职业\" desc = \"自由职业者\" [[params.about.status]] title = \"地点\" faIcon = \"fas fa-map-marker-alt\" desc = \"地球\" # 参数说明 [[params.about.parameter]] language = \"UI/UX\" level = \"80\" [[params.about.parameter]] language = \"HTML\" level = \"70\" [[params.about.parameter]] language = \"Go\" level = \"60\" # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # display image-preview imagePreview = true # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # oEmbed config [params.oembed] # Privacy config (https://gohugo.io/about/hugo-and-gdpr/) privacy = false [params.oembed.facebook] # Facebook Aplication Identity and Cl","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, FeelIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/FeelIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 多语言和 i18n FeelIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换 ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 德语 de de 英语 en en 西班牙语 es es 法语 fr fr 印度尼西亚 id id 意大利语 it it 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 罗马尼亚语 ro ro 俄语 ru ru 塞尔维亚语 sr sr 越南语 vi vi 简体中文 zh-cn zh-CN 波斯语 fa fa ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/FeelIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 搜索 基于 Lunr.js 或 algolia, FeelIt 主题支持搜索功能. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎? 以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"博客主题概念文档","uri":"/theme-documentation-basics/"}]